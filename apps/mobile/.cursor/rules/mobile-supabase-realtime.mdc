---
description: 
globs: 
alwaysApply: false
---
# CivicSense Mobile Supabase Real-Time Development Rules

*Optimized for blazing fast performance, real-time news feeds, and multiplayer gaming*

## ðŸš€ Core Performance Principles

### 1. Connection Management
- **Single Supabase Instance**: Always use one shared client instance across the app
- **Connection Pooling**: Leverage Supabase's built-in connection pooling
- **Lazy Loading**: Initialize real-time subscriptions only when screens are active
- **Cleanup**: Always unsubscribe from channels when components unmount

### 2. Real-Time Subscription Architecture
```typescript
// packages/shared/database/realtime-client.ts
import { createClient, RealtimeChannel } from '@supabase/supabase-js';

class RealtimeManager {
  private channels = new Map<string, RealtimeChannel>();
  private client = createClient(url, key);

  subscribe(channelName: string, config: ChannelConfig) {
    // Reuse existing channels to prevent memory leaks
    if (this.channels.has(channelName)) {
      return this.channels.get(channelName)!;
    }

    const channel = this.client.channel(channelName, {
      config: { presence: { key: config.userId } }
    });

    this.channels.set(channelName, channel);
    return channel;
  }

  unsubscribe(channelName: string) {
    const channel = this.channels.get(channelName);
    if (channel) {
      channel.unsubscribe();
      this.channels.delete(channelName);
    }
  }

  cleanup() {
    this.channels.forEach(channel => channel.unsubscribe());
    this.channels.clear();
  }
}

export const realtimeManager = new RealtimeManager();
```

## ðŸ“° Real-Time News Feed Optimization

### 1. Efficient News Polling Strategy
```typescript
// packages/shared/news/realtime-news.ts
export class RealtimeNewsService {
  private static BATCH_SIZE = 20;
  private static POLL_INTERVAL = 30000; // 30 seconds
  
  static async setupNewsFeed(userId: string) {
    // Use database changes instead of polling
    const channel = realtimeManager.subscribe('news_feed', { userId });
    
    channel
      .on('postgres_changes', {
        event: 'INSERT',
        schema: 'public',
        table: 'news_articles',
        filter: `created_at=gte.${new Date().toISOString()}`
      }, (payload) => {
        // Immediately update local state
        this.handleNewArticle(payload.new);
      })
      .on('postgres_changes', {
        event: 'UPDATE',
        schema: 'public',
        table: 'news_articles'
      }, (payload) => {
        this.handleArticleUpdate(payload.new);
      })
      .subscribe();
  }

  // Prefetch news with smart caching
  static async prefetchNews(categories: string[]) {
    const cacheKey = `news_${categories.join('_')}`;
    const cached = await AsyncStorage.getItem(cacheKey);
    
    if (cached && this.isCacheValid(cached)) {
      return JSON.parse(cached);
    }

    const { data } = await supabase
      .from('news_articles')
      .select('*')
      .in('category', categories)
      .order('created_at', { ascending: false })
      .limit(this.BATCH_SIZE);

    await AsyncStorage.setItem(cacheKey, JSON.stringify({
      data,
      timestamp: Date.now()
    }));

    return data;
  }
}
```

### 2. Optimized News UI Components
```typescript
// packages/ui-mobile/src/components/news/NewsFeed.tsx
import React, { useEffect, useCallback, useMemo } from 'react';
import { FlatList, RefreshControl } from 'react-native';

export const NewsFeed: React.FC = () => {
  const [news, setNews] = useState<NewsArticle[]>([]);
  const [refreshing, setRefreshing] = useState(false);

  // Memoize expensive operations
  const sortedNews = useMemo(() => 
    news.sort((a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime()),
    [news]
  );

  const renderItem = useCallback(({ item }: { item: NewsArticle }) => (
    <NewsCard article={item} />
  ), []);

  const keyExtractor = useCallback((item: NewsArticle) => item.id, []);

  useEffect(() => {
    const setupRealtime = async () => {
      await RealtimeNewsService.setupNewsFeed(userId);
    };
    
    setupRealtime();
    
    return () => {
      realtimeManager.unsubscribe('news_feed');
    };
  }, [userId]);

  return (
    <FlatList
      data={sortedNews}
      renderItem={renderItem}
      keyExtractor={keyExtractor}
      refreshControl={
        <RefreshControl refreshing={refreshing} onRefresh={onRefresh} />
      }
      // Performance optimizations
      removeClippedSubviews={true}
      maxToRenderPerBatch={10}
      windowSize={10}
      initialNumToRender={5}
      getItemLayout={getItemLayout} // If items have fixed height
    />
  );
};
```

## ðŸŽ® Multiplayer Game Real-Time Architecture

### 1. Game State Management
```typescript
// packages/shared/multiplayer/game-state.ts
export class MultiplayerGameState {
  private gameChannel: RealtimeChannel;
  private gameState: GameState;
  private lastUpdateTime = 0;
  private UPDATE_THROTTLE = 100; // 100ms throttle

  constructor(roomId: string, userId: string) {
    this.gameChannel = realtimeManager.subscribe(`game_${roomId}`, { userId });
    this.setupGameListeners();
  }

  private setupGameListeners() {
    this.gameChannel
      .on('broadcast', { event: 'game_update' }, (payload) => {
        this.handleGameUpdate(payload);
      })
      .on('broadcast', { event: 'player_action' }, (payload) => {
        this.handlePlayerAction(payload);
      })
      .on('presence', { event: 'sync' }, () => {
        this.handlePresenceSync();
      })
      .on('presence', { event: 'join' }, ({ key, newPresences }) => {
        this.handlePlayerJoin(newPresences);
      })
      .on('presence', { event: 'leave' }, ({ key, leftPresences }) => {
        this.handlePlayerLeave(leftPresences);
      })
      .subscribe();
  }

  // Throttled state updates to prevent spam
  broadcastGameUpdate(update: Partial<GameState>) {
    const now = Date.now();
    if (now - this.lastUpdateTime < this.UPDATE_THROTTLE) {
      return;
    }

    this.lastUpdateTime = now;
    this.gameChannel.send({
      type: 'broadcast',
      event: 'game_update',
      payload: {
        ...update,
        timestamp: now,
        playerId: this.userId
      }
    });
  }

  // Immediate actions (button presses, answers)
  broadcastPlayerAction(action: PlayerAction) {
    this.gameChannel.send({
      type: 'broadcast',
      event: 'player_action',
      payload: {
        ...action,
        timestamp: Date.now(),
        playerId: this.userId
      }
    });
  }

  // Track player presence
  updatePresence(status: PresenceStatus) {
    this.gameChannel.track({
      user_id: this.userId,
      status,
      last_seen: new Date().toISOString()
    });
  }
}
```

### 2. Optimized Database Functions for Games
```sql
-- supabase/migrations/050_multiplayer_game_optimizations.sql

-- Ultra-fast room joining with atomic operations
CREATE OR REPLACE FUNCTION join_game_room_atomic(
  p_room_id UUID,
  p_user_id UUID,
  p_display_name TEXT
) RETURNS JSON AS $$
DECLARE
  room_data JSON;
  player_count INTEGER;
BEGIN
  -- Single atomic operation to join room
  WITH room_update AS (
    UPDATE multiplayer_rooms 
    SET 
      current_players = current_players + 1,
      updated_at = NOW()
    WHERE 
      id = p_room_id 
      AND status = 'waiting'
      AND current_players < max_players
    RETURNING *
  ),
  player_insert AS (
    INSERT INTO multiplayer_players (room_id, user_id, display_name, joined_at)
    SELECT p_room_id, p_user_id, p_display_name, NOW()
    FROM room_update
    RETURNING *
  )
  SELECT 
    json_build_object(
      'room', row_to_json(room_update),
      'player', row_to_json(player_insert),
      'success', true
    ) INTO room_data
  FROM room_update, player_insert;

  -- If no room_data, room was full or not found
  IF room_data IS NULL THEN
    RETURN json_build_object('success', false, 'error', 'Room full or not found');
  END IF;

  RETURN room_data;
END;
$$ LANGUAGE plpgsql;

-- Batch update player scores for performance
CREATE OR REPLACE FUNCTION update_player_scores_batch(
  p_room_id UUID,
  p_score_updates JSON[]
) RETURNS VOID AS $$
BEGIN
  UPDATE multiplayer_players 
  SET 
    score = score + (score_update->>'points')::INTEGER,
    updated_at = NOW()
  FROM unnest(p_score_updates) AS score_update
  WHERE 
    room_id = p_room_id 
    AND user_id = (score_update->>'user_id')::UUID;
END;
$$ LANGUAGE plpgsql;

-- Optimized leaderboard query with caching
CREATE OR REPLACE FUNCTION get_room_leaderboard(p_room_id UUID)
RETURNS TABLE(
  user_id UUID,
  display_name TEXT,
  score INTEGER,
  rank INTEGER
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    mp.user_id,
    mp.display_name,
    mp.score,
    ROW_NUMBER() OVER (ORDER BY mp.score DESC)::INTEGER as rank
  FROM multiplayer_players mp
  WHERE mp.room_id = p_room_id
  ORDER BY mp.score DESC;
END;
$$ LANGUAGE plpgsql;
```

### 3. Real-Time Game UI Components
```typescript
// packages/ui-mobile/src/components/multiplayer/GameRoom.tsx
import React, { useEffect, useReducer, useCallback } from 'react';
import { View, Text, Pressable, Animated } from 'react-native';

interface GameRoomProps {
  roomId: string;
  userId: string;
}

export const GameRoom: React.FC<GameRoomProps> = ({ roomId, userId }) => {
  const [gameState, dispatch] = useReducer(gameReducer, initialGameState);
  const [gameManager] = useState(() => new MultiplayerGameState(roomId, userId));
  
  // Animated values for smooth UI updates
  const scoreAnimation = useRef(new Animated.Value(0)).current;
  const timerAnimation = useRef(new Animated.Value(100)).current;

  const handleAnswer = useCallback((answer: string) => {
    // Immediate UI feedback
    dispatch({ type: 'ANSWER_SUBMITTED', payload: { answer } });
    
    // Broadcast to other players
    gameManager.broadcastPlayerAction({
      type: 'answer',
      answer,
      questionId: gameState.currentQuestion?.id
    });
  }, [gameState.currentQuestion?.id]);

  const animateScore = useCallback((newScore: number) => {
    Animated.timing(scoreAnimation, {
      toValue: newScore,
      duration: 500,
      useNativeDriver: false
    }).start();
  }, []);

  useEffect(() => {
    // Setup real-time listeners
    gameManager.onGameUpdate((update) => {
      dispatch({ type: 'GAME_UPDATE', payload: update });
    });

    gameManager.onPlayerAction((action) => {
      dispatch({ type: 'PLAYER_ACTION', payload: action });
    });

    gameManager.onPresenceChange((presence) => {
      dispatch({ type: 'PRESENCE_UPDATE', payload: presence });
    });

    return () => {
      gameManager.cleanup();
    };
  }, []);

  return (
    <View style={styles.container}>
      <GameHeader 
        players={gameState.players}
        timer={gameState.timer}
        timerAnimation={timerAnimation}
      />
      
      <QuestionCard 
        question={gameState.currentQuestion}
        onAnswer={handleAnswer}
        disabled={gameState.answered}
      />
      
      <ScoreBoard 
        scores={gameState.scores}
        scoreAnimation={scoreAnimation}
      />
    </View>
  );
};
```

## âš¡ Performance Optimization Strategies

### 1. Database Query Optimization
```typescript
// packages/shared/database/optimized-queries.ts
export class OptimizedQueries {
  // Use prepared statements for repeated queries
  static async getQuizQuestions(topicId: string, limit: number = 10) {
    const { data, error } = await supabase.rpc('get_quiz_questions_optimized', {
      p_topic_id: topicId,
      p_limit: limit,
      p_user_id: getCurrentUserId()
    });

    if (error) throw error;
    return data;
  }

  // Batch operations for better performance
  static async batchUpdateProgress(updates: ProgressUpdate[]) {
    const { error } = await supabase.rpc('batch_update_user_progress', {
      p_updates: updates
    });

    if (error) throw error;
  }

  // Use materialized views for complex aggregations
  static async getUserStats(userId: string) {
    const { data, error } = await supabase
      .from('user_stats_materialized')
      .select('*')
      .eq('user_id', userId)
      .single();

    if (error) throw error;
    return data;
  }
}
```

### 2. Caching Strategy
```typescript
// packages/shared/cache/mobile-cache.ts
import AsyncStorage from '@react-native-async-storage/async-storage';

export class MobileCache {
  private static TTL = {
    NEWS: 5 * 60 * 1000,      // 5 minutes
    QUIZ: 30 * 60 * 1000,     // 30 minutes
    USER_PROFILE: 60 * 60 * 1000, // 1 hour
    LEADERBOARD: 2 * 60 * 1000,   // 2 minutes
  };

  static async get<T>(key: string, ttl: number): Promise<T | null> {
    try {
      const cached = await AsyncStorage.getItem(key);
      if (!cached) return null;

      const { data, timestamp } = JSON.parse(cached);
      if (Date.now() - timestamp > ttl) {
        await AsyncStorage.removeItem(key);
        return null;
      }

      return data;
    } catch {
      return null;
    }
  }

  static async set(key: string, data: any): Promise<void> {
    try {
      await AsyncStorage.setItem(key, JSON.stringify({
        data,
        timestamp: Date.now()
      }));
    } catch (error) {
      console.warn('Cache write failed:', error);
    }
  }

  // Smart cache invalidation
  static async invalidatePattern(pattern: string): Promise<void> {
    try {
      const keys = await AsyncStorage.getAllKeys();
      const matchingKeys = keys.filter(key => key.includes(pattern));
      await AsyncStorage.multiRemove(matchingKeys);
    } catch (error) {
      console.warn('Cache invalidation failed:', error);
    }
  }
}
```

### 3. Connection Resilience
```typescript
// packages/shared/database/connection-manager.ts
export class ConnectionManager {
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;
  private reconnectDelay = 1000;

  async handleConnectionLoss() {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      // Switch to offline mode
      this.enableOfflineMode();
      return;
    }

    this.reconnectAttempts++;
    
    // Exponential backoff
    const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);
    
    setTimeout(async () => {
      try {
        await this.reconnect();
        this.reconnectAttempts = 0;
      } catch (error) {
        this.handleConnectionLoss();
      }
    }, delay);
  }

  private async reconnect() {
    // Test connection with lightweight query
    const { error } = await supabase.from('health_check').select('id').limit(1);
    if (error) throw error;

    // Reestablish real-time connections
    await this.reestablishRealTimeConnections();
  }

  private enableOfflineMode() {
    // Queue operations for when connection is restored
    // Use local storage for critical data
    // Show offline indicator to user
  }
}
```

## ðŸ”„ Real-Time Best Practices

### 1. Channel Management
```typescript
// packages/shared/realtime/channel-manager.ts
export class ChannelManager {
  private static instance: ChannelManager;
  private channels = new Map<string, RealtimeChannel>();
  private subscriptionCounts = new Map<string, number>();

  static getInstance(): ChannelManager {
    if (!this.instance) {
      this.instance = new ChannelManager();
    }
    return this.instance;
  }

  subscribe(channelName: string, callback: Function): () => void {
    let channel = this.channels.get(channelName);
    
    if (!channel) {
      channel = supabase.channel(channelName);
      this.channels.set(channelName, channel);
      channel.subscribe();
    }

    // Track subscription count
    const count = this.subscriptionCounts.get(channelName) || 0;
    this.subscriptionCounts.set(channelName, count + 1);

    // Add callback
    channel.on('broadcast', { event: '*' }, callback);

    // Return unsubscribe function
    return () => {
      const currentCount = this.subscriptionCounts.get(channelName) || 0;
      if (currentCount <= 1) {
        // Last subscriber, clean up channel
        channel?.unsubscribe();
        this.channels.delete(channelName);
        this.subscriptionCounts.delete(channelName);
      } else {
        this.subscriptionCounts.set(channelName, currentCount - 1);
      }
    };
  }
}
```

### 2. Optimized Presence Tracking
```typescript
// packages/shared/realtime/presence-tracker.ts
export class PresenceTracker {
  private presenceChannel: RealtimeChannel;
  private heartbeatInterval: NodeJS.Timeout;
  private lastHeartbeat = 0;

  constructor(channelName: string, userId: string) {
    this.presenceChannel = supabase.channel(channelName, {
      config: { presence: { key: userId } }
    });

    this.setupPresence(userId);
    this.startHeartbeat();
  }

  private setupPresence(userId: string) {
    this.presenceChannel
      .on('presence', { event: 'sync' }, () => {
        const state = this.presenceChannel.presenceState();
        this.handlePresenceSync(state);
      })
      .on('presence', { event: 'join' }, ({ key, newPresences }) => {
        this.handleUserJoin(newPresences);
      })
      .on('presence', { event: 'leave' }, ({ key, leftPresences }) => {
        this.handleUserLeave(leftPresences);
      })
      .subscribe(async (status) => {
        if (status === 'SUBSCRIBED') {
          await this.presenceChannel.track({
            user_id: userId,
            online_at: new Date().toISOString(),
            status: 'online'
          });
        }
      });
  }

  private startHeartbeat() {
    this.heartbeatInterval = setInterval(() => {
      this.lastHeartbeat = Date.now();
      this.presenceChannel.track({
        last_heartbeat: this.lastHeartbeat
      });
    }, 30000); // 30 second heartbeat
  }

  cleanup() {
    if (this.heartbeatInterval) {
      clearInterval(this.heartbeatInterval);
    }
    this.presenceChannel.unsubscribe();
  }
}
```

## ðŸ“Š Performance Monitoring

### 1. Real-Time Metrics
```typescript
// packages/shared/monitoring/performance-monitor.ts
export class PerformanceMonitor {
  private metrics = new Map<string, number[]>();

  trackLatency(operation: string, startTime: number) {
    const latency = Date.now() - startTime;
    
    if (!this.metrics.has(operation)) {
      this.metrics.set(operation, []);
    }
    
    this.metrics.get(operation)!.push(latency);
    
    // Keep only last 100 measurements
    if (this.metrics.get(operation)!.length > 100) {
      this.metrics.get(operation)!.shift();
    }

    // Alert if latency is too high
    if (latency > 1000) {
      console.warn(`High latency detected for ${operation}: ${latency}ms`);
    }
  }

  getAverageLatency(operation: string): number {
    const measurements = this.metrics.get(operation) || [];
    if (measurements.length === 0) return 0;
    
    return measurements.reduce((sum, val) => sum + val, 0) / measurements.length;
  }

  // Track real-time message frequency
  trackMessageFrequency(channel: string) {
    const key = `messages_${channel}`;
    const now = Date.now();
    
    if (!this.metrics.has(key)) {
      this.metrics.set(key, []);
    }
    
    this.metrics.get(key)!.push(now);
    
    // Clean old messages (> 1 minute)
    this.metrics.set(key, 
      this.metrics.get(key)!.filter(time => now - time < 60000)
    );
  }
}

export const performanceMonitor = new PerformanceMonitor();
```

## ðŸŽ¯ Mobile-Specific Optimizations

### 1. Background/Foreground Handling
```typescript
// packages/shared/lifecycle/app-state-manager.ts
import { AppState, AppStateStatus } from 'react-native';

export class AppStateManager {
  private currentState: AppStateStatus = AppState.currentState;
  private realtimeConnections: RealtimeChannel[] = [];

  constructor() {
    AppState.addEventListener('change', this.handleAppStateChange);
  }

  private handleAppStateChange = (nextAppState: AppStateStatus) => {
    if (this.currentState.match(/inactive|background/) && nextAppState === 'active') {
      // App came to foreground
      this.handleAppForeground();
    } else if (this.currentState === 'active' && nextAppState.match(/inactive|background/)) {
      // App went to background
      this.handleAppBackground();
    }
    
    this.currentState = nextAppState;
  };

  private handleAppForeground() {
    // Reconnect real-time channels
    this.realtimeConnections.forEach(channel => {
      if (channel.state === 'closed') {
        channel.subscribe();
      }
    });

    // Refresh critical data
    this.refreshCriticalData();
  }

  private handleAppBackground() {
    // Reduce real-time activity to save battery
    this.realtimeConnections.forEach(channel => {
      // Don't fully disconnect, just reduce frequency
      channel.send({
        type: 'broadcast',
        event: 'reduce_frequency'
      });
    });
  }
}
```

### 2. Battery Optimization
```typescript
// packages/shared/optimization/battery-optimizer.ts
export class BatteryOptimizer {
  private static BATTERY_SAVE_THRESHOLD = 20; // 20% battery
  private static isLowBattery = false;

  static async checkBatteryLevel(): Promise<number> {
    // Would use expo-battery or similar
    // For now, return mock value
    return 50;
  }

  static async optimizeForBattery() {
    const batteryLevel = await this.checkBatteryLevel();
    
    if (batteryLevel < this.BATTERY_SAVE_THRESHOLD) {
      this.isLowBattery = true;
      this.enableBatterySaveMode();
    } else {
      this.isLowBattery = false;
      this.disableBatterySaveMode();
    }
  }

  private static enableBatterySaveMode() {
    // Reduce real-time polling frequency
    // Disable animations
    // Reduce background sync
    console.log('Battery save mode enabled');
  }

  private static disableBatterySaveMode() {
    // Restore normal operation
    console.log('Battery save mode disabled');
  }

  static shouldReduceActivity(): boolean {
    return this.isLowBattery;
  }
}
```

## ðŸ”§ Development Tools & Debugging

### 1. Real-Time Debugging
```typescript
// packages/shared/debug/realtime-debugger.ts
export class RealtimeDebugger {
  private static enabled = __DEV__;
  private static logs: DebugLog[] = [];

  static log(channel: string, event: string, payload: any) {
    if (!this.enabled) return;

    const log: DebugLog = {
      timestamp: Date.now(),
      channel,
      event,
      payload,
      type: 'realtime'
    };

    this.logs.push(log);
    
    // Keep only last 1000 logs
    if (this.logs.length > 1000) {
      this.logs.shift();
    }

    console.log(`[REALTIME] ${channel}:${event}`, payload);
  }

  static getLogs(channel?: string): DebugLog[] {
    return channel 
      ? this.logs.filter(log => log.channel === channel)
      : this.logs;
  }

  static exportLogs(): string {
    return JSON.stringify(this.logs, null, 2);
  }
}
```

---

## âœ… Performance Checklist

Before deploying real-time features:

- [ ] **Connection Management**: Single Supabase client instance
- [ ] **Subscription Cleanup**: All channels properly unsubscribed
- [ ] **Throttling**: Updates throttled to prevent spam
- [ ] **Caching**: Appropriate caching strategy implemented
- [ ] **Offline Handling**: Graceful degradation when offline
- [ ] **Battery Optimization**: Reduced activity on low battery
- [ ] **Memory Management**: No memory leaks in real-time subscriptions
- [ ] **Error Handling**: Robust error handling and recovery
- [ ] **Latency Monitoring**: Performance metrics tracked
- [ ] **Background Behavior**: Proper handling of app state changes

---

*Follow these rules to build blazing fast, real-time mobile experiences that scale*
