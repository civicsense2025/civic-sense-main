/**
 * Enhanced Congressional Sync Service for CivicSense Platform
 * Integrates Congress.gov API and GovInfo API for comprehensive legislative analysis
 * Includes automated event generation, entity extraction, and CivicSense-style analysis
 */

import { createClient } from '@supabase/supabase-js';
import type { SupabaseClient } from '@supabase/supabase-js';
import { CongressAPIClient } from '@/lib/integrations/congress-api';
import GovInfoAPIClient from '@/lib/integrations/govinfo-api';
import { CivicSenseBillAnalyzer } from '@/lib/ai/bill-analyzer';
import { CongressionalPhotoServiceLocal } from './congressional-photo-service-local';
import { CongressionalDocumentQuizGenerator } from './congressional-document-quiz-generator';
import OpenAI from 'openai';

// Create service role client for admin operations that need to bypass RLS
const createServiceClient = () => {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
};

interface SyncResults {
  synced: number;
  errors: number;
  details?: any[];
}

interface HearingAnalysis {
  civic_education_summary: string;
  uncomfortable_truths: string[];
  power_dynamics_revealed: string[];
  stakeholder_analysis: any;
  lobbying_influence_detected: boolean;
  contradictions_found: string[];
  civic_education_value: number;
  controversy_level: number;
}

interface WitnessAnalysis {
  credibility_score: number;
  expertise_relevance: number;
  political_leaning: string;
  testimony_summary: string;
  key_arguments: string[];
  uncomfortable_truths_revealed: string[];
  lobbying_connections: string[];
  financial_conflicts_of_interest: string[];
}

interface QAAnalysis {
  question_type: string;
  response_quality: string;
  topic_areas: string[];
  civic_education_significance: number;
  reveals_power_dynamics: boolean;
  demonstrates_government_process: boolean;
  exposes_institutional_failures: boolean;
  educational_summary: string;
}

interface AutoGeneratedEvent {
  event_title: string;
  event_description: string;
  event_date: string;
  event_type: string;
  why_this_matters: string;
  uncomfortable_truths: string[];
  power_dynamics_revealed: string[];
  action_items: string[];
  civic_significance_score: number;
}

export class EnhancedCongressSyncService {
  private congressAPI: CongressAPIClient;
  private govInfoAPI: GovInfoAPIClient;
  private supabase: SupabaseClient;
  private billAnalyzer: CivicSenseBillAnalyzer;
  private photoService: CongressionalPhotoServiceLocal;
  private quizGenerator: CongressionalDocumentQuizGenerator;
  private openai: OpenAI;
  private supportedCongresses: number[];

  constructor() {
    this.congressAPI = new CongressAPIClient({
      baseUrl: process.env.NEXT_PUBLIC_CONGRESS_API_BASE_URL || 'https://api.congress.gov/v3',
      apiKey: process.env.CONGRESS_API_KEY!,
      rateLimitPerSecond: 1
    });
    
    this.govInfoAPI = new GovInfoAPIClient();
    
    // Use service role client to bypass RLS policies for administrative operations
    this.supabase = createServiceClient();
    
    this.billAnalyzer = new CivicSenseBillAnalyzer();
    this.photoService = new CongressionalPhotoServiceLocal();
    this.quizGenerator = new CongressionalDocumentQuizGenerator();
    
    this.openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY!,
    });
    
    // Support multiple congressional classes
    this.supportedCongresses = [117, 118, 119]; // 117th, 118th, 119th Congress
    
    console.log('üöÄ Enhanced Congress Sync Service initialized successfully');
  }

  // ============================================================================
  // COMPREHENSIVE SYNC OPERATIONS WITH MULTI-CONGRESS SUPPORT
  // ============================================================================

  /**
   * Perform comprehensive sync of all congressional data sources
   * Now supports multiple congressional classes
   */
  async performComprehensiveSync(options: {
    syncBills?: boolean;
    syncMembers?: boolean;
    syncHearings?: boolean;
    syncCommitteeDocuments?: boolean;
    generateEvents?: boolean;
    extractEntities?: boolean;
    generateQuizContent?: boolean;
    congressNumbers?: number[];
    limit?: number;
  } = {}): Promise<{
    bills: SyncResults;
    members: SyncResults;
    hearings: SyncResults;
    committeeDocuments: SyncResults;
    events: SyncResults;
    entities: SyncResults;
    quizContent: SyncResults;
  }> {
    const {
      syncBills = true,
      syncMembers = true,
      syncHearings = true,
      syncCommitteeDocuments = true,
      generateEvents = true,
      extractEntities = true,
      generateQuizContent = true,
      congressNumbers = this.supportedCongresses,
      limit = 50
    } = options;

    console.log(`üöÄ Starting comprehensive congressional sync for congresses: ${congressNumbers.join(', ')}`);

    const results = {
      bills: { synced: 0, errors: 0 },
      members: { synced: 0, errors: 0 },
      hearings: { synced: 0, errors: 0 },
      committeeDocuments: { synced: 0, errors: 0 },
      events: { synced: 0, errors: 0 },
      entities: { synced: 0, errors: 0 },
      quizContent: { synced: 0, errors: 0 }
    };

    try {
      // Process each congress
      for (const congressNumber of congressNumbers) {
        console.log(`\nüìä Processing ${congressNumber}th Congress...`);
        
        // 1. Sync congressional members (foundation for everything else)
        if (syncMembers) {
          console.log(`üë• Syncing congressional members for ${congressNumber}th Congress...`);
          const memberResults = await this.syncCongressionalMembers(congressNumber);
          results.members.synced += memberResults.synced;
          results.members.errors += memberResults.errors;
        }

        // 2. Sync bills with GovInfo enhancement
        if (syncBills) {
          console.log(`üìú Syncing bills with GovInfo enhancement for ${congressNumber}th Congress...`);
          const billResults = await this.syncBillsWithGovInfo(limit, congressNumber);
          results.bills.synced += billResults.synced;
          results.bills.errors += billResults.errors;
        }

        // 3. Sync congressional hearings
        if (syncHearings) {
          console.log(`üèõÔ∏è Syncing congressional hearings for ${congressNumber}th Congress...`);
          const hearingResults = await this.syncCongressionalHearings(limit, congressNumber);
          results.hearings.synced += hearingResults.synced;
          results.hearings.errors += hearingResults.errors;
        }

        // 4. Sync committee documents
        if (syncCommitteeDocuments) {
          console.log(`üìã Syncing committee documents for ${congressNumber}th Congress...`);
          const docResults = await this.syncCommitteeDocuments(limit, congressNumber);
          results.committeeDocuments.synced += docResults.synced;
          results.committeeDocuments.errors += docResults.errors;
        }
      }

      // 5. Generate events from processed documents (across all congresses)
      if (generateEvents) {
        console.log('üìÖ Generating events from documents...');
        results.events = await this.generateEventsFromDocuments();
      }

      // 6. Extract entities and relationships (across all congresses)
      if (extractEntities) {
        console.log('üîó Extracting entities and relationships...');
        results.entities = await this.extractEntitiesAndRelationships();
      }
      
      // 7. Generate quiz content from documents
      if (generateQuizContent) {
        console.log('üìù Generating quiz content from documents...');
        results.quizContent = await this.generateQuizContentFromDocuments();
      }

      console.log('‚úÖ Comprehensive sync completed:', results);
      return results;

    } catch (error) {
      console.error('‚ùå Comprehensive sync failed:', error);
      throw error;
    }
  }

  // ============================================================================
  // BILLS SYNC WITH GOVINFO ENHANCEMENT
  // ============================================================================

  /**
   * Sync bills from Congress.gov and enhance with GovInfo data
   * Now supports specific congress numbers
   */
  async syncBillsWithGovInfo(limit: number = 50, congressNumber: number = 118): Promise<SyncResults> {
    const results: SyncResults = { synced: 0, errors: 0, details: [] };

    try {
      // Get recent bills from Congress.gov for specific congress
      const billsResponse = await this.congressAPI.getBills({
        congress: congressNumber,
        limit,
        fromDateTime: this.getRecentDateTime()
      });

      const bills = billsResponse.bills || [];

      for (const billData of bills) {
        try {
          const result = await this.processBillWithGovInfo(billData, congressNumber);
          if (result.success) {
            results.synced++;
          } else {
            results.errors++;
            results.details?.push(result.error);
          }
        } catch (error) {
          console.error(`Error processing bill ${billData.title}:`, error);
          results.errors++;
        }
      }

      return results;
    } catch (error) {
      console.error('Error in syncBillsWithGovInfo:', error);
      throw error;
    }
  }

  private async processBillWithGovInfo(billData: any, congressNumber: number): Promise<{ success: boolean; error?: string }> {
    try {
      // Process with existing Congress sync logic first
      const congressResult = await this.processBillFromCongress(billData, congressNumber);
      
      if (!congressResult.success) {
        return congressResult;
      }

      // Try to find corresponding GovInfo package
      const govInfoPackage = await this.findGovInfoPackageForBill(billData);
      
      if (govInfoPackage) {
        // Update bill with GovInfo package ID
        await this.supabase
          .from('congressional_bills')
          .update({
            govinfo_package_id: govInfoPackage.package_id,
            govinfo_last_sync: new Date().toISOString(),
            govinfo_metadata: govInfoPackage
          })
          .eq('congress_api_id', billData.url);

        // Store GovInfo document
        await this.storeGovInfoDocument(govInfoPackage, 'BILLS');
        
        // Generate quiz content from bill
        if (govInfoPackage.content) {
          await this.generateQuizContentForBill(billData, govInfoPackage);
        }
      }

      return { success: true };
    } catch (error) {
      return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
    }
  }

  private async processBillFromCongress(billData: any, congressNumber: number): Promise<{ success: boolean; error?: string }> {
    // Reuse existing bill processing logic from the original CongressSyncService
    // This includes text analysis, sponsor matching, etc.
    try {
      // Check if bill already exists
      const { data: existingBill } = await this.supabase
        .from('congressional_bills')
        .select('id, last_content_update, has_placeholder_text')
        .eq('congress_api_id', billData.url)
        .eq('congress_number', congressNumber)
        .single();

      if (existingBill && this.isRecentlyUpdated(existingBill.last_content_update)) {
        return { success: true }; // Skip if recently processed
      }

      // Get comprehensive bill data from Congress API
      const [textData, summariesData, actionsData, subjectsData, cosponsorsData] = await Promise.all([
        this.congressAPI.getBillText(billData.congress, billData.type, billData.number),
        this.congressAPI.getBillSummaries(billData.congress, billData.type, billData.number),
        this.congressAPI.getBillActions(billData.congress, billData.type, billData.number),
        this.congressAPI.getBillSubjects(billData.congress, billData.type, billData.number),
        this.congressAPI.getBillCosponsors(billData.congress, billData.type, billData.number)
      ]);

      // Map comprehensive bill data
      const billRecord = {
        congress_api_id: billData.url,
        congress_number: congressNumber,
        bill_type: billData.type.toLowerCase(),
        bill_number: billData.number,
        title: billData.title,
        short_title: billData.shortTitle,
        official_title: billData.officialTitle,
        current_status: billData.latestAction?.text || 'Unknown',
        introduced_date: billData.introducedDate,
        last_action_date: billData.latestAction?.actionDate,
        last_action_text: billData.latestAction?.text,
        summary_text: summariesData?.summaries?.[0]?.text,
        has_placeholder_text: textData.isPlaceholder,
        last_content_update: new Date().toISOString(),
        primary_sponsor_id: await this.findMemberByBioguide(billData.sponsors?.[0]?.bioguideId)
      };

      // Upsert bill
      const { data: savedBill, error } = await this.supabase
        .from('congressional_bills')
        .upsert(billRecord, { 
          onConflict: 'congress_api_id',
          ignoreDuplicates: false 
        })
        .select()
        .single();

      if (error) {
        return { success: false, error: error.message };
      }

      // Process related data
      await Promise.all([
        this.processBillSummaries(savedBill.id, summariesData),
        this.processBillActions(savedBill.id, actionsData),
        this.processBillSubjects(savedBill.id, subjectsData),
        this.processBillCosponsors(savedBill.id, cosponsorsData)
      ]);

      // Generate content if not placeholder text
      if (!textData.isPlaceholder && textData.content) {
        await this.generateBillContent(savedBill, textData.content);
      }

      return { success: true };
    } catch (error) {
      return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
    }
  }

  // ============================================================================
  // CONGRESSIONAL MEMBERS SYNC WITH LOCAL PHOTO STORAGE
  // ============================================================================

  /**
   * Sync congressional members for a specific congress with local photo storage
   */
  async syncCongressionalMembers(congressNumber: number): Promise<SyncResults> {
    const results: SyncResults = { synced: 0, errors: 0, details: [] };
    
    try {
      console.log(`üîÑ Starting member sync for ${congressNumber}th Congress...`);
      
      // Use getAllMembers to fetch all members with pagination
      const membersResponse = await this.congressAPI.getAllMembers({ congress: congressNumber });
      const members = membersResponse.members;
      
      console.log(`Found ${members?.length || 0} members in ${congressNumber}th Congress`);
      
      if (!members || !Array.isArray(members)) {
        console.error('Invalid members response structure:', membersResponse);
        throw new Error('Members API returned invalid data structure');
      }
      
      if (members.length === 0) {
        console.warn(`No members found for ${congressNumber}th Congress`);
        return results;
      }
      
      console.log(`üìä Processing ${members.length} members across ${membersResponse.pagination?.pages || 1} pages...`);
      
      for (const memberData of members) {
        try {
          await this.processMember(memberData, congressNumber);
          results.synced++;
          
          // Log progress every 50 members
          if (results.synced % 50 === 0) {
            console.log(`üîÑ Progress: ${results.synced}/${members.length} members processed`);
          }
        } catch (error) {
          console.error(`Error processing member ${memberData.firstName || 'Unknown'} ${memberData.lastName || 'Unknown'}:`, error);
          results.errors++;
          results.details?.push({
            member: `${memberData.firstName || 'Unknown'} ${memberData.lastName || 'Unknown'}`,
            bioguideId: memberData.bioguideId,
            error: error instanceof Error ? error.message : 'Unknown error'
          });
        }
      }
      
      console.log(`‚úÖ Member sync completed: ${results.synced} synced, ${results.errors} errors`);
      return results;
    } catch (error) {
      console.error(`‚ùå Error syncing members for ${congressNumber}th Congress:`, error);
      throw error;
    }
  }

  private async processMember(memberData: any, congressNumber: number): Promise<void> {
    console.log('Processing member:', memberData.name, 'with data:', JSON.stringify(memberData, null, 2));
    
    // Parse the name field into first and last name
    let firstName = '';
    let lastName = '';
    
    if (memberData.name) {
      // Handle formats like "Ramirez, Delia C." or "Johnson, Mike"
      const nameParts = memberData.name.split(',').map((p: string) => p.trim());
      if (nameParts.length >= 2) {
        lastName = nameParts[0];
        firstName = nameParts[1];
      } else {
        // Fallback for single names
        const singleNameParts = memberData.name.split(' ');
        firstName = singleNameParts[0] || '';
        lastName = singleNameParts.slice(1).join(' ') || '';
      }
    }
    
    // Validate required member data
    if (!memberData.bioguideId || !firstName || !lastName) {
      console.error('Missing required member data:', {
        bioguideId: memberData.bioguideId,
        firstName: firstName,
        lastName: lastName
      });
      throw new Error(`Invalid member data: missing required fields for ${memberData.name}`);
    }
    
    // Check if member exists in public_figures
    const { data: existingFigure } = await this.supabase
      .from('public_figures')
      .select('id')
      .eq('bioguide_id', memberData.bioguideId)
      .single();
    
    // Process terms data - handle both array and object formats
    let termsArray: any[] = [];
    if (memberData.terms) {
      if (Array.isArray(memberData.terms)) {
        termsArray = memberData.terms;
      } else if (memberData.terms.item && Array.isArray(memberData.terms.item)) {
        termsArray = memberData.terms.item;
      } else if (typeof memberData.terms === 'object') {
        // Convert single term object to array
        termsArray = [memberData.terms];
      }
    }
    
    // Get current term info for positioning
    const currentTerm = termsArray[0] || {};
    const memberType = currentTerm.chamber === 'House of Representatives' ? 'Representative' : 'Senator';
    const office = currentTerm.chamber || 'Congress';
    
    // Create position descriptions array
    const positions = termsArray.map((term: any) => {
      const chamber = term.chamber === 'House of Representatives' ? 'Representative' : 'Senator';
      const startYear = term.startYear || 'Unknown';
      const endYear = term.endYear || 'present';
      return `${chamber} (${startYear}-${endYear})`;
    });
    
    // CRITICAL: Create member record with ONLY existing database columns
    const memberRecord = {
      bioguide_id: memberData.bioguideId,
      full_name: `${firstName} ${lastName}`,
      display_name: `${firstName} ${lastName}`,
      congress_member_type: memberType,
      current_state: memberData.state,
      current_district: memberData.district,
      party_affiliation: memberData.partyName,
      congressional_tenure_start: currentTerm.startYear ? `${currentTerm.startYear}-01-01` : null,
      is_active: true,
      is_politician: true,
      office: office,
      current_positions: positions,
      region: memberData.state,
      congress_api_last_sync: new Date().toISOString()
      // NOTE: Removed 'description' field as it doesn't exist in database schema
    };
    
    console.log('Member record to insert/update:', JSON.stringify(memberRecord, null, 2));
    
    let figureId: string;
    
    try {
      if (existingFigure) {
        // Update existing figure
        console.log(`üîÑ Updating existing member: ${firstName} ${lastName} (${memberData.bioguideId})`);
        const { error: updateError } = await this.supabase
          .from('public_figures')
          .update(memberRecord)
          .eq('id', existingFigure.id);
          
        if (updateError) {
          console.error('Update error:', updateError);
          throw new Error(`Failed to update member: ${updateError.message}`);
        }
        
        figureId = existingFigure.id;
        console.log(`‚úÖ Updated existing member: ${firstName} ${lastName} (${memberData.bioguideId})`);
      } else {
        // Insert new figure with duplicate handling
        console.log(`‚ûï Creating new member: ${firstName} ${lastName} (${memberData.bioguideId})`);
        const slug = this.generateSlug(`${firstName} ${lastName}`);
        
        const { data: newFigure, error: insertError } = await this.supabase
          .from('public_figures')
          .insert({
            ...memberRecord,
            slug: slug
          })
          .select('id')
          .single();
        
        if (insertError) {
          // Handle duplicate slug constraint error
          if (insertError.code === '23505' && insertError.message.includes('slug')) {
            console.log(`‚ö†Ô∏è Duplicate slug detected for ${firstName} ${lastName}, trying with modified slug...`);
            
            // Try with bioguide_id suffix to make it unique
            const uniqueSlug = `${slug}-${memberData.bioguideId.toLowerCase()}`;
            const { data: retryFigure, error: retryError } = await this.supabase
              .from('public_figures')
              .insert({
                ...memberRecord,
                slug: uniqueSlug
              })
              .select('id')
              .single();
            
            if (retryError) {
              // If still failing, try to find if a record with this bioguide_id already exists
              console.log(`‚ö†Ô∏è Retry failed, checking for existing bioguide_id: ${memberData.bioguideId}`);
              const { data: existingByBioguide } = await this.supabase
                .from('public_figures')
                .select('id')
                .eq('bioguide_id', memberData.bioguideId)
                .single();
              
              if (existingByBioguide) {
                console.log(`‚úÖ Found existing record by bioguide_id, using: ${existingByBioguide.id}`);
                figureId = existingByBioguide.id;
              } else {
                console.error('Final retry error:', retryError);
                console.error('Attempted to insert with unique slug:', { ...memberRecord, slug: uniqueSlug });
                // Don't throw error, just skip this member to continue sync
                console.log(`‚ö†Ô∏è Skipping member ${firstName} ${lastName} due to unresolvable duplicate`);
                return;
              }
            } else {
              figureId = retryFigure!.id;
              console.log(`‚úÖ Created new member with unique slug: ${firstName} ${lastName} (${memberData.bioguideId})`);
            }
          } else {
            console.error('Insert error:', insertError);
            console.error('Attempted to insert:', { ...memberRecord, slug: slug });
            throw new Error(`Failed to insert member: ${insertError.message}`);
          }
        } else {
          figureId = newFigure!.id;
          console.log(`‚úÖ Created new member: ${firstName} ${lastName} (${memberData.bioguideId})`);
        }
      }
    } catch (dbError) {
      console.error(`‚ùå Database error for ${firstName} ${lastName}:`, dbError);
      throw dbError;
    }
    
    // Process congressional terms
    if (termsArray.length > 0) {
      for (const term of termsArray) {
        await this.processCongressionalTerm(figureId, term, memberData.bioguideId);
      }
    }
    
    // Download and store official photo
    try {
      const photoResult = await this.photoService.downloadAndStorePhoto(
        memberData.bioguideId, 
        figureId,
        congressNumber
      );
      
      if (photoResult.success) {
        console.log(`üì∑ Photo processed for: ${firstName} ${lastName} (${memberData.bioguideId})`);
      } else {
        console.log(`‚ö†Ô∏è Photo failed for: ${firstName} ${lastName} (${memberData.bioguideId}) - ${photoResult.error}`);
      }
    } catch (photoError) {
      console.warn(`üì∑ Photo processing error for ${firstName} ${lastName}:`, photoError);
      // Don't fail the whole process for photo errors
    }
  }
  
  private generateSlug(name: string): string {
    return name
      .toLowerCase()
      .replace(/[^a-z0-9\s-]/g, '')
      .replace(/\s+/g, '-')
      .trim();
  }
  
  private async processCongressionalTerm(memberId: string, termData: any, bioguideId: string) {
    try {
      const termRecord = {
        member_id: memberId,
        congress_number: termData.congress || termData.startYear ? Math.floor((termData.startYear - 1789) / 2) + 1 : null,
        chamber: termData.chamber === 'House of Representatives' ? 'house' : 'senate',
        state_code: termData.stateCode || termData.state,
        district: termData.district || null,
        start_year: termData.startYear,
        end_year: termData.endYear || null,
        party_affiliation: termData.party || termData.partyName,
        member_type: termData.chamber === 'House of Representatives' ? 'representative' : 'senator'
      };
      
      await this.supabase
        .from('congressional_terms')
        .upsert(termRecord, { 
          onConflict: 'member_id,congress_number,chamber',
          ignoreDuplicates: false 
        });
        
      console.log(`üìã Processed term for ${bioguideId}: ${termRecord.chamber} ${termRecord.start_year}-${termRecord.end_year || 'present'}`);
    } catch (error) {
      console.error(`Error processing term for ${bioguideId}:`, error);
    }
  }

  // ============================================================================
  // CONGRESSIONAL HEARINGS SYNC WITH QUIZ GENERATION
  // ============================================================================

  /**
   * Sync congressional hearings from GovInfo with quiz generation
   */
  async syncCongressionalHearings(limit: number = 25, congressNumber: number = 118): Promise<SyncResults> {
    console.log(`üèõÔ∏è Syncing congressional hearings for ${congressNumber}th Congress...`);
    const results: SyncResults = { synced: 0, errors: 0, details: [] };

    try {
      // First, validate the API connection
      const validation = await this.govInfoAPI.validateConnection();
      if (!validation.success) {
        console.error(`‚ùå API validation failed: ${validation.message}`);
        throw new Error(`GovInfo API validation failed: ${validation.message}`);
      }
      console.log(`‚úÖ API connection validated successfully`);

      // Try multiple strategies to get hearings
      let hearingsResponse;
      
      try {
        // Strategy 1: Recent hearings with date filter
        hearingsResponse = await this.govInfoAPI.searchHearings({
          congress: congressNumber,
          publishedDate: this.getRecentDate(),
          pageSize: limit
        });
      } catch (dateError) {
        console.warn(`‚ö†Ô∏è Date-filtered search failed, trying without date filter:`, dateError);
        
        try {
          // Strategy 2: No date filter, just congress
          hearingsResponse = await this.govInfoAPI.searchHearings({
            congress: congressNumber,
            pageSize: limit
          });
        } catch (congressError) {
          console.warn(`‚ö†Ô∏è Congress-filtered search failed, trying basic search:`, congressError);
          
          // Strategy 3: Very basic search
          hearingsResponse = await this.govInfoAPI.searchHearings({
            pageSize: 10 // Very small limit
          });
        }
      }

      if (!hearingsResponse?.packages) {
        console.warn(`‚ö†Ô∏è No hearing packages found in response`);
        return results;
      }

      console.log(`üìã Found ${hearingsResponse.packages.length} hearing packages`);

      for (const packageData of hearingsResponse.packages) {
        try {
          const result = await this.processHearing(packageData, congressNumber);
          if (result.success) {
            results.synced++;
          } else {
            results.errors++;
            results.details?.push({
              packageId: packageData.packageId,
              error: result.error
            });
          }
        } catch (error) {
          results.errors++;
          console.error(`Error processing hearing ${packageData.packageId}:`, error);
          results.details?.push({
            packageId: packageData.packageId,
            error: error instanceof Error ? error.message : 'Unknown error'
          });
        }
      }

      console.log(`‚úÖ Hearing sync completed: ${results.synced} synced, ${results.errors} errors`);
      return results;
    } catch (error) {
      console.error('Error in syncCongressionalHearings:', error);
      
      // If all strategies failed, check if it's an API key issue
      if (error instanceof Error && error.message.includes('401')) {
        console.error('‚ùå Authentication failed - check your GovInfo API key');
      } else if (error instanceof Error && error.message.includes('500')) {
        console.error('‚ùå GovInfo API server error - may be temporary, try again later');
      }
      
      throw error;
    }
  }

  private async processHearing(packageData: any, congressNumber: number): Promise<{ success: boolean; error?: string }> {
    try {
      // Get full hearing document with analysis
      const hearingDoc = await this.govInfoAPI.getHearingPackage(packageData.packageId);
      
      if (!hearingDoc) {
        return { success: false, error: 'Could not retrieve hearing document' };
      }

      // Store GovInfo document
      const govInfoDocId = await this.storeGovInfoDocument(hearingDoc, 'CHRG');

      // Analyze hearing content with CivicSense approach
      const hearingAnalysis = await this.analyzeHearing(hearingDoc);

      // Store hearing record
      const hearingRecord = {
        govinfo_document_id: govInfoDocId,
        hearing_title: hearingDoc.title,
        committee_code: this.extractCommitteeCode(hearingDoc.title),
        committee_name: packageData.committees?.[0] || 'Unknown Committee',
        chamber: this.detectChamber(hearingDoc.title),
        congress_number: congressNumber,
        hearing_date: packageData.dateIssued || new Date().toISOString().split('T')[0],
        hearing_type: this.categorizeHearingType(hearingDoc.title, (hearingDoc as any).content),
        ...hearingAnalysis
      };

      const { data: savedHearing, error } = await this.supabase
        .from('congressional_hearings')
        .upsert(hearingRecord, { onConflict: 'govinfo_document_id' })
        .select()
        .single();

      if (error) {
        return { success: false, error: error.message };
      }

      // Process witnesses
      if (hearingDoc.witnesses) {
        await this.processHearingWitnesses(savedHearing.id, hearingDoc.witnesses, (hearingDoc as any).content || '');
      }

      // Process Q&A exchanges
      if (hearingDoc.qaExchanges) {
        await this.processQAExchanges(savedHearing.id, hearingDoc.qaExchanges);
      }

      // Generate quiz content from hearing
      await this.generateQuizContentForHearing(savedHearing, hearingDoc);

      return { success: true };
    } catch (error) {
      return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
    }
  }

  // ============================================================================
  // QUIZ CONTENT GENERATION
  // ============================================================================

  /**
   * Generate quiz content from all processed documents
   */
  async generateQuizContentFromDocuments(): Promise<SyncResults> {
    const results: SyncResults = { synced: 0, errors: 0, details: [] };

    try {
      // Process bills
      const billResults = await this.quizGenerator.processAllDocuments('bill', 10);
      results.synced += billResults.succeeded;
      results.errors += billResults.failed;

      // Process hearings
      const hearingResults = await this.quizGenerator.processAllDocuments('hearing', 10);
      results.synced += hearingResults.succeeded;
      results.errors += hearingResults.failed;

      // Process committee documents
      const docResults = await this.quizGenerator.processAllDocuments('committee_document', 10);
      results.synced += docResults.succeeded;
      results.errors += docResults.failed;

      return results;
    } catch (error) {
      console.error('Error generating quiz content:', error);
      throw error;
    }
  }

  /**
   * Generate quiz content for a specific bill
   */
  private async generateQuizContentForBill(billData: any, govInfoPackage: any): Promise<void> {
    try {
      await this.quizGenerator.processDocument({
        documentType: 'bill',
        documentId: billData.id,
        documentTitle: billData.title,
        documentContent: govInfoPackage.content || billData.summary_text || '',
        metadata: {
          congress_number: billData.congress,
          bill_type: billData.type,
          bill_number: billData.number
        }
      });
      
      console.log(`‚úÖ Quiz content generated for bill: ${billData.title}`);
    } catch (error) {
      console.error(`Failed to generate quiz content for bill ${billData.title}:`, error);
    }
  }

  /**
   * Generate quiz content for a specific hearing
   */
  private async generateQuizContentForHearing(hearing: any, hearingDoc: any): Promise<void> {
    try {
      await this.quizGenerator.processDocument({
        documentType: 'hearing',
        documentId: hearing.id,
        documentTitle: hearing.hearing_title,
        documentContent: (hearingDoc as any).content || hearing.civic_education_summary || '',
        metadata: {
          congress_number: hearing.congress_number,
          committee: hearing.committee_name,
          hearing_date: hearing.hearing_date
        }
      });
      
      console.log(`‚úÖ Quiz content generated for hearing: ${hearing.hearing_title}`);
    } catch (error) {
      console.error(`Failed to generate quiz content for hearing ${hearing.hearing_title}:`, error);
    }
  }

  // ============================================================================
  // COMMITTEE DOCUMENTS SYNC
  // ============================================================================

  /**
   * Sync committee documents from GovInfo
   */
  async syncCommitteeDocuments(limit: number = 25, congressNumber: number = 118): Promise<SyncResults> {
    const results: SyncResults = { synced: 0, errors: 0, details: [] };

    try {
      // Get committee reports
      const reportsResponse = await this.govInfoAPI.searchCommitteeDocuments({
        congress: congressNumber,
        docClass: 'CRPT',
        pageSize: limit
      });

      // Get committee prints
      const printsResponse = await this.govInfoAPI.searchCommitteeDocuments({
        congress: congressNumber,
        docClass: 'CPRT',
        pageSize: limit
      });

      const allDocuments = [
        ...(reportsResponse.packages || []),
        ...(printsResponse.packages || [])
      ];

      for (const packageData of allDocuments) {
        try {
          const result = await this.processCommitteeDocument(packageData, congressNumber);
          if (result.success) {
            results.synced++;
          } else {
            results.errors++;
            results.details?.push(result.error);
          }
        } catch (error) {
          console.error(`Error processing document ${packageData.title}:`, error);
          results.errors++;
        }
      }

      return results;
    } catch (error) {
      console.error('Error in syncCommitteeDocuments:', error);
      throw error;
    }
  }

  private async processCommitteeDocument(packageData: any, congressNumber: number): Promise<{ success: boolean; error?: string }> {
    try {
      // Get full document
      const document = await this.govInfoAPI.getCommitteeDocument(packageData.packageId);
      
      if (!document) {
        return { success: false, error: 'Could not retrieve committee document' };
      }

      // Store GovInfo document
      const govInfoDocId = await this.storeGovInfoDocument(document, packageData.collectionCode);

      // Analyze document content
      const documentAnalysis = await this.analyzeCommitteeDocument(document);

      // Store committee document record
      const documentRecord = {
        govinfo_document_id: govInfoDocId,
        document_title: document.title,
        committee_code: this.extractCommitteeCode(document.title),
        committee_name: packageData.committees?.[0] || 'Unknown Committee',
        congress_number: congressNumber,
        document_type: this.categorizeDocumentType(packageData.collectionCode),
        issue_date: packageData.dateIssued || new Date().toISOString().split('T')[0],
        ...documentAnalysis
      };

      const { data: savedDocument, error } = await this.supabase
        .from('committee_documents')
        .upsert(documentRecord, { onConflict: 'govinfo_document_id' })
        .select()
        .single();

      if (error) {
        return { success: false, error: error.message };
      }

      // Generate quiz content from document
      await this.generateQuizContentForDocument(savedDocument, document);

      return { success: true };
    } catch (error) {
      return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
    }
  }

  /**
   * Generate quiz content for a committee document
   */
  private async generateQuizContentForDocument(documentRecord: any, document: any): Promise<void> {
    try {
      await this.quizGenerator.processDocument({
        documentType: 'committee_document',
        documentId: documentRecord.id,
        documentTitle: documentRecord.document_title,
        documentContent: (document as any).content || '',
        metadata: {
          congress_number: documentRecord.congress_number,
          committee: documentRecord.committee_name,
          document_type: documentRecord.document_type
        }
      });
      
      console.log(`‚úÖ Quiz content generated for document: ${documentRecord.document_title}`);
    } catch (error) {
      console.error(`Failed to generate quiz content for document ${documentRecord.document_title}:`, error);
    }
  }

  // ============================================================================
  // SHARED METHODS AND UTILITIES
  // ============================================================================

  private async analyzeHearing(hearingDoc: any): Promise<HearingAnalysis> {
    const prompt = `
      As a CivicSense analyst, analyze this congressional hearing with brutal honesty and civic education focus.

      Hearing: ${hearingDoc.title}
      Content: ${(hearingDoc as any).content?.substring(0, 4000) || 'No content available'}

      Provide analysis in this format:
      {
        "civic_education_summary": "Plain English explanation of what this hearing reveals about how government works",
        "uncomfortable_truths": ["Truth 1", "Truth 2"],
        "power_dynamics_revealed": ["Power dynamic 1", "Power dynamic 2"],
        "stakeholder_analysis": {
          "winners": ["Who benefits"],
          "losers": ["Who gets hurt"],
          "hidden_players": ["Who's pulling strings behind scenes"]
        },
        "lobbying_influence_detected": true/false,
        "contradictions_found": ["Contradiction 1"],
        "civic_education_value": 1-10,
        "controversy_level": 1-10
      }

      Focus on:
      - How this reveals the actual workings of power
      - What citizens need to know that's usually hidden
      - Who's really benefiting vs. who's getting the runaround
      - Corporate influence and regulatory capture
      - Empty political theater vs. real accountability
    `;

    try {
      const response = await this.openai.chat.completions.create({
        model: 'gpt-4-turbo-preview',
        messages: [{ role: 'user', content: prompt }],
        response_format: { type: 'json_object' },
        temperature: 0.3
      });

      const analysis = JSON.parse(response.choices[0].message.content || '{}');
      return {
        civic_education_summary: analysis.civic_education_summary || '',
        uncomfortable_truths: analysis.uncomfortable_truths || [],
        power_dynamics_revealed: analysis.power_dynamics_revealed || [],
        stakeholder_analysis: analysis.stakeholder_analysis || {},
        lobbying_influence_detected: analysis.lobbying_influence_detected || false,
        contradictions_found: analysis.contradictions_found || [],
        civic_education_value: analysis.civic_education_value || 5,
        controversy_level: analysis.controversy_level || 5
      };
    } catch (error) {
      console.error('Error analyzing hearing:', error);
      return {
        civic_education_summary: 'Analysis pending',
        uncomfortable_truths: [],
        power_dynamics_revealed: [],
        stakeholder_analysis: {},
        lobbying_influence_detected: false,
        contradictions_found: [],
        civic_education_value: 5,
        controversy_level: 1
      };
    }
  }

  private async analyzeWitness(witness: any, hearingContent: string): Promise<WitnessAnalysis> {
    const prompt = `
      Analyze this congressional hearing witness for civic education value.

      Witness: ${witness.name}
      Title: ${witness.title || 'Not provided'}
      Organization: ${witness.organization || 'Not provided'}

      Context from hearing content:
      ${hearingContent.substring(0, 2000)}

      Provide analysis in this format:
      {
        "credibility_score": 1-10,
        "expertise_relevance": 1-10,
        "political_leaning": "assessment of political stance",
        "testimony_summary": "key points from their testimony",
        "key_arguments": ["Argument 1", "Argument 2"],
        "uncomfortable_truths_revealed": ["Truth 1", "Truth 2"],
        "lobbying_connections": ["Connection 1", "Connection 2"],
        "financial_conflicts_of_interest": ["Conflict 1", "Conflict 2"]
      }

      Focus on:
      - Former industry positions now in government
      - Campaign contributions influencing testimony
      - Think tank funding sources
      - Revolving door examples
      - Hidden agendas
    `;

    try {
      const response = await this.openai.chat.completions.create({
        model: 'gpt-4-turbo-preview',
        messages: [{ role: 'user', content: prompt }],
        response_format: { type: 'json_object' },
        temperature: 0.3
      });

      const analysis = JSON.parse(response.choices[0].message.content || '{}');
      return {
        credibility_score: analysis.credibility_score || 5,
        expertise_relevance: analysis.expertise_relevance || 5,
        political_leaning: analysis.political_leaning || 'Unknown',
        testimony_summary: analysis.testimony_summary || '',
        key_arguments: analysis.key_arguments || [],
        uncomfortable_truths_revealed: analysis.uncomfortable_truths_revealed || [],
        lobbying_connections: analysis.lobbying_connections || [],
        financial_conflicts_of_interest: analysis.financial_conflicts_of_interest || []
      };
    } catch (error) {
      console.error('Error analyzing witness:', error);
      return {
        credibility_score: 5,
        expertise_relevance: 5,
        political_leaning: 'Unknown',
        testimony_summary: '',
        key_arguments: [],
        uncomfortable_truths_revealed: [],
        lobbying_connections: [],
        financial_conflicts_of_interest: []
      };
    }
  }

  private async processHearingWitnesses(hearingId: string, witnesses: any[], content: string) {
    for (const witness of witnesses) {
      try {
        const witnessAnalysis = await this.analyzeWitness(witness, content);
        
        // Try to link to existing public figure
        const publicFigureId = await this.findPublicFigureByName(witness.name);

        // Store witness record
        await this.supabase
          .from('hearing_witnesses')
          .insert({
            hearing_id: hearingId,
            witness_name: witness.name,
            witness_title: witness.title,
            witness_organization: witness.organization,
            witness_type: witness.witnessType || 'Unknown',
            public_figure_id: publicFigureId,
            ...witnessAnalysis
          });
      } catch (error) {
        console.error(`Error processing witness ${witness.name}:`, error);
      }
    }
  }

  private async processQAExchanges(hearingId: string, qaExchanges: any[]) {
    for (const exchange of qaExchanges) {
      try {
        const qaAnalysis = await this.analyzeQAExchange(exchange);
        
        // Try to link questioner to public figure
        const questionerFigureId = await this.findPublicFigureByName(exchange.questioner);

        // Store Q&A exchange
        await this.supabase
          .from('hearing_qa_exchanges')
          .insert({
            hearing_id: hearingId,
            questioner_name: exchange.questioner,
            questioner_public_figure_id: questionerFigureId,
            respondent_name: exchange.respondent,
            question_text: exchange.question,
            response_text: exchange.response,
            exchange_timestamp: exchange.timestamp,
            ...qaAnalysis
          });
      } catch (error) {
        console.error('Error processing Q&A exchange:', error);
      }
    }
  }

  private async analyzeQAExchange(exchange: any): Promise<QAAnalysis> {
    const prompt = `
      Analyze this congressional hearing Q&A exchange for civic education value.

      Questioner: ${exchange.questioner}
      Question: ${exchange.question}
      
      Respondent: ${exchange.respondent}
      Response: ${exchange.response}

      Provide analysis in this format:
      {
        "question_type": "type of question (friendly/hostile/neutral/procedural)",
        "response_quality": "quality of response (evasive/direct/misleading/comprehensive)",
        "topic_areas": ["Topic 1", "Topic 2"],
        "civic_education_significance": 1-10,
        "reveals_power_dynamics": true/false,
        "demonstrates_government_process": true/false,
        "exposes_institutional_failures": true/false,
        "educational_summary": "What citizens learn from this exchange"
      }
    `;

    try {
      const response = await this.openai.chat.completions.create({
        model: 'gpt-4-turbo-preview',
        messages: [{ role: 'user', content: prompt }],
        response_format: { type: 'json_object' },
        temperature: 0.3
      });

      const analysis = JSON.parse(response.choices[0].message.content || '{}');
      return {
        question_type: analysis.question_type || 'Unknown',
        response_quality: analysis.response_quality || 'Unknown',
        topic_areas: analysis.topic_areas || [],
        civic_education_significance: analysis.civic_education_significance || 5,
        reveals_power_dynamics: analysis.reveals_power_dynamics || false,
        demonstrates_government_process: analysis.demonstrates_government_process || false,
        exposes_institutional_failures: analysis.exposes_institutional_failures || false,
        educational_summary: analysis.educational_summary || ''
      };
    } catch (error) {
      console.error('Error analyzing Q&A exchange:', error);
      return {
        question_type: 'Unknown',
        response_quality: 'Unknown',
        topic_areas: [],
        civic_education_significance: 5,
        reveals_power_dynamics: false,
        demonstrates_government_process: false,
        exposes_institutional_failures: false,
        educational_summary: ''
      };
    }
  }

  // ============================================================================
  // EVENT GENERATION
  // ============================================================================

  /**
   * Generate civic education events from analyzed documents
   */
  async generateEventsFromDocuments(): Promise<SyncResults> {
    const results: SyncResults = { synced: 0, errors: 0, details: [] };

    try {
      // Get recent analyzed hearings
      const { data: hearings } = await this.supabase
        .from('congressional_hearings')
        .select('*')
        .eq('auto_generated_event', false)
        .gte('civic_education_value', 7)
        .limit(20);

      for (const hearing of hearings || []) {
        try {
          const event = await this.generateEventFromHearing(hearing);
          if (event) {
            await this.storeAutoGeneratedEvent(event, 'hearing', hearing.id);
            results.synced++;
          }
        } catch (error) {
          results.errors++;
          console.error('Error generating event from hearing:', error);
        }
      }

      // Get recent analyzed committee documents
      const { data: documents } = await this.supabase
        .from('committee_documents')
        .select('*')
        .eq('auto_generated_event', false)
        .gte('civic_education_value', 7)
        .limit(20);

      for (const document of documents || []) {
        try {
          const event = await this.generateEventFromCommitteeDocument(document);
          if (event) {
            await this.storeAutoGeneratedEvent(event, 'committee_document', undefined, document.id);
            results.synced++;
          }
        } catch (error) {
          results.errors++;
          console.error('Error generating event from document:', error);
        }
      }

      return results;
    } catch (error) {
      console.error('Error in generateEventsFromDocuments:', error);
      throw error;
    }
  }

  private async generateEventFromHearing(hearing: any): Promise<AutoGeneratedEvent | null> {
    const prompt = `
      Create a civic education event from this analyzed congressional hearing.

      Hearing: ${hearing.hearing_title}
      Date: ${hearing.hearing_date}
      Summary: ${hearing.civic_education_summary}
      Uncomfortable Truths: ${hearing.uncomfortable_truths?.join('; ')}
      Power Dynamics: ${hearing.power_dynamics_revealed?.join('; ')}

      Generate event in this format:
      {
        "event_title": "Engaging title that makes people want to learn",
        "event_description": "What happened and why it matters",
        "event_date": "${hearing.hearing_date}",
        "event_type": "congressional_hearing",
        "why_this_matters": "Direct explanation of impact on citizens",
        "uncomfortable_truths": ["Truth 1", "Truth 2"],
        "power_dynamics_revealed": ["Dynamic 1", "Dynamic 2"],
        "action_items": ["Action 1", "Action 2", "Action 3"],
        "civic_significance_score": 1-10
      }
    `;

    try {
      const response = await this.openai.chat.completions.create({
        model: 'gpt-4-turbo-preview',
        messages: [{ role: 'user', content: prompt }],
        response_format: { type: 'json_object' },
        temperature: 0.5
      });

      return JSON.parse(response.choices[0].message.content || '{}');
    } catch (error) {
      console.error('Error generating event from hearing:', error);
      return null;
    }
  }

  private async generateEventFromCommitteeDocument(document: any): Promise<AutoGeneratedEvent | null> {
    const prompt = `
      Create a civic education event from this committee document.

      Document: ${document.document_title}
      Type: ${document.document_type}
      Date: ${document.issue_date}
      Summary: ${document.civic_education_summary}

      Generate event following the same format as hearing events.
    `;

    try {
      const response = await this.openai.chat.completions.create({
        model: 'gpt-4-turbo-preview',
        messages: [{ role: 'user', content: prompt }],
        response_format: { type: 'json_object' },
        temperature: 0.5
      });

      return JSON.parse(response.choices[0].message.content || '{}');
    } catch (error) {
      console.error('Error generating event from document:', error);
      return null;
    }
  }

  // ============================================================================
  // ENTITY EXTRACTION
  // ============================================================================

  /**
   * Extract entities and relationships from documents
   */
  async extractEntitiesAndRelationships(): Promise<SyncResults> {
    const results: SyncResults = { synced: 0, errors: 0, details: [] };

    try {
      // Process recent hearings
      const { data: hearings } = await this.supabase
        .from('congressional_hearings')
        .select('*')
        .is('entities_extracted', null)
        .limit(10);

      for (const hearing of hearings || []) {
        try {
          await this.extractEntitiesFromHearing(hearing);
          results.synced++;
        } catch (error) {
          results.errors++;
          console.error('Error extracting entities from hearing:', error);
        }
      }

      return results;
    } catch (error) {
      console.error('Error in extractEntitiesAndRelationships:', error);
      throw error;
    }
  }

  private async extractEntitiesFromHearing(hearing: any) {
    // Get witnesses
    const { data: witnesses } = await this.supabase
      .from('hearing_witnesses')
      .select('*')
      .eq('hearing_id', hearing.id);

    // Extract organization entities
    const organizations = new Set<string>();
    for (const witness of witnesses || []) {
      if (witness.witness_organization) {
        organizations.add(witness.witness_organization);
      }
      
      // Extract from lobbying connections
      for (const connection of witness.lobbying_connections || []) {
        // Parse organization names from connection strings
        const orgMatch = connection.match(/([A-Z][a-zA-Z\s&]+(?:Inc\.|LLC|Corp\.|Corporation|Group|Association))/g);
        if (orgMatch) {
          orgMatch.forEach((org: string) => organizations.add(org.trim()));
        }
      }
    }

    // Store organization entities
    for (const orgName of organizations) {
      try {
        const orgRecord = {
          organization_name: orgName,
          organization_type: this.categorizeOrganizationType(orgName),
          first_appearance_date: hearing.hearing_date,
          related_hearings: [hearing.id],
          influence_indicators: {
            witness_appearances: 1,
            lobbying_mentions: witnesses?.filter((w: any) => 
              w.lobbying_connections?.some((c: string) => c.includes(orgName))
            ).length || 0
          }
        };

        await this.supabase
          .from('congressional_organizations')
          .upsert(orgRecord, { onConflict: 'organization_name' });
      } catch (error) {
        console.error(`Error storing organization ${orgName}:`, error);
      }
    }

    // Create entity relationships
    for (const witness of witnesses || []) {
      if (witness.public_figure_id && witness.witness_organization) {
        try {
          await this.supabase
            .from('entity_relationships')
            .upsert({
              entity_1_type: 'person',
              entity_1_id: witness.public_figure_id,
              entity_2_type: 'organization',
              entity_2_name: witness.witness_organization,
              relationship_type: 'affiliated_with',
              relationship_context: `Testified at hearing: ${hearing.hearing_title}`,
              start_date: hearing.hearing_date,
              source_type: 'congressional_hearing',
              source_id: hearing.id
            }, { onConflict: 'entity_1_id,entity_2_name,relationship_type' });
        } catch (error) {
          console.error('Error creating entity relationship:', error);
        }
      }
    }

    // Mark hearing as processed
    await this.supabase
      .from('congressional_hearings')
      .update({ entities_extracted: true })
      .eq('id', hearing.id);
  }

  // ============================================================================
  // HELPER METHODS
  // ============================================================================

  private async storeGovInfoDocument(document: any, collectionCode: string): Promise<string> {
    const { data, error } = await this.supabase
      .from('govinfo_documents')
      .upsert({
        package_id: document.packageId,
        collection_code: collectionCode,
        title: document.title,
        summary: document.summary,
        category: document.category,
        metadata: document,
        content: (document as any).content || null,
        download_date: new Date().toISOString()
      }, { onConflict: 'package_id' })
      .select('id')
      .single();

    if (error) {
      throw new Error(`Failed to store GovInfo document: ${error.message}`);
    }

    return data.id;
  }

  private async storeAutoGeneratedEvent(
    event: AutoGeneratedEvent, 
    sourceType: string, 
    hearingId?: string, 
    documentId?: string
  ) {
    const eventRecord = {
      event_title: event.event_title,
      event_description: event.event_description,
      event_date: event.event_date,
      event_type: event.event_type,
      why_this_matters: event.why_this_matters,
      action_steps: event.action_items,
      uncomfortable_truths: event.uncomfortable_truths,
      civic_significance: event.civic_significance_score,
      auto_generated: true,
      generation_source: sourceType,
      hearing_id: hearingId,
      document_id: documentId,
      status: 'pending_review'
    };

    await this.supabase
      .from('civic_events')
      .insert(eventRecord);

    // Mark source as having generated event
    if (sourceType === 'hearing' && hearingId) {
      await this.supabase
        .from('congressional_hearings')
        .update({ auto_generated_event: true })
        .eq('id', hearingId);
    } else if (sourceType === 'committee_document' && documentId) {
      await this.supabase
        .from('committee_documents')
        .update({ auto_generated_event: true })
        .eq('id', documentId);
    }
  }

  private getRecentDateTime(): string {
    const date = new Date();
    date.setDate(date.getDate() - 7);
    return date.toISOString().replace(/\.\d{3}Z$/, 'Z');
  }

  private getRecentDate(): string {
    const date = new Date();
    date.setDate(date.getDate() - 7);
    return date.toISOString().split('T')[0];
  }

  private isRecentlyUpdated(lastUpdate: string): boolean {
    if (!lastUpdate) return false;
    const lastUpdateDate = new Date(lastUpdate);
    const oneDayAgo = new Date();
    oneDayAgo.setDate(oneDayAgo.getDate() - 1);
    return lastUpdateDate > oneDayAgo;
  }

  private extractCommitteeCode(title: string): string {
    // Extract committee codes like HASC, SASC, etc.
    const match = title.match(/\b([A-Z]{2,5})\b/);
    return match ? match[1] : 'UNK';
  }

  private detectChamber(title: string): string {
    if (title.toLowerCase().includes('senate')) return 'senate';
    if (title.toLowerCase().includes('house')) return 'house';
    return 'joint';
  }

  private categorizeHearingType(title: string, content?: string): string {
    const lowerTitle = title.toLowerCase();
    if (lowerTitle.includes('nomination')) return 'nomination';
    if (lowerTitle.includes('oversight')) return 'oversight';
    if (lowerTitle.includes('budget')) return 'budget';
    if (lowerTitle.includes('confirmation')) return 'confirmation';
    return 'general';
  }

  private categorizeDocumentType(collection: string): string {
    if (collection === 'CRPT') return 'committee_report';
    if (collection === 'CPRT') return 'committee_print';
    return 'other';
  }

  private categorizeOrganizationType(organization?: string): string {
    if (!organization) return 'unknown';
    const lowerOrg = organization.toLowerCase();
    if (lowerOrg.includes('inc') || lowerOrg.includes('corp') || lowerOrg.includes('llc')) return 'corporation';
    if (lowerOrg.includes('association') || lowerOrg.includes('society')) return 'association';
    if (lowerOrg.includes('foundation') || lowerOrg.includes('institute')) return 'think_tank';
    if (lowerOrg.includes('university') || lowerOrg.includes('college')) return 'academic';
    return 'other';
  }

  private async findGovInfoPackageForBill(billData: any): Promise<any> {
    try {
      // Use searchBills instead of non-existent searchRelatedDocuments
      const results = await this.govInfoAPI.searchBills({
        congress: billData.congress,
        query: `${billData.type} ${billData.number}`,
        collections: ['BILLS']
      });
      
      // Find the most relevant package
      const billPackage = results.packages?.find((pkg: any) => 
        pkg.packageId.includes(billData.type.toUpperCase()) &&
        pkg.packageId.includes(billData.number.toString())
      );
      
      return billPackage || null;
    } catch (error) {
      console.error('Error finding GovInfo package:', error);
      return null;
    }
  }

  private async findMemberByBioguide(bioguideId?: string): Promise<string | null> {
    if (!bioguideId) return null;
    
    const { data } = await this.supabase
      .from('public_figures')
      .select('id')
      .eq('bioguide_id', bioguideId)
      .single();
    
    return data?.id || null;
  }

  private async findPublicFigureByName(name: string): Promise<string | null> {
    if (!name) return null;
    
    // Try exact match first
    const { data: exactMatch } = await this.supabase
      .from('public_figures')
      .select('id')
      .or(`full_name.eq.${name},display_name.eq.${name}`)
      .single();
    
    if (exactMatch) return exactMatch.id;
    
    // Try fuzzy match
    const { data: fuzzyMatch } = await this.supabase
      .from('public_figures')
      .select('id')
      .ilike('full_name', `%${name}%`)
      .limit(1)
      .single();
    
    return fuzzyMatch?.id || null;
  }

  // Delegate methods to keep compatibility
  private async processBillSummaries(billId: string, summariesData: any): Promise<void> {
    // Implementation from original service
  }

  private async processBillActions(billId: string, actionsData: any): Promise<void> {
    // Implementation from original service
  }

  private async processBillSubjects(billId: string, subjectsData: any): Promise<void> {
    // Implementation from original service
  }

  private async processBillCosponsors(billId: string, cosponsorsData: any): Promise<void> {
    // Implementation from original service
  }

  private async generateBillContent(bill: any, textContent: any): Promise<void> {
    // Implementation from original service
  }

  private async analyzeCommitteeDocument(document: any): Promise<any> {
    // Similar to analyzeHearing but for committee documents
    return {
      civic_education_summary: 'Analysis pending',
      uncomfortable_truths: [],
      power_dynamics_revealed: [],
      civic_education_value: 5
    };
  }
} 