---
description: 
globs: 
alwaysApply: true
---
# Supabase Best Practices & Development Guidelines

## Migration Philosophy

### Targeted Patches & Incremental Updates
- Supabase migrations should be **targeted patches**, always learning from the previous, and not overriding past fixes
- This prevents reverting back into a loop of mismatched fixes and worsens the problem and mental load
- Build upon existing schema rather than recreating from scratch

### Idempotent Scripts
- Supabase scripts should be **idempotent** where it makes sense
- Use `CREATE TABLE IF NOT EXISTS`, `ALTER TABLE IF EXISTS`, `DROP INDEX IF EXISTS`, etc.
- Use `UPDATE/ALTER` to add additional columns/schema to existing tables if a full rewrite is not needed
- Always check for existence before creating/dropping objects

```sql
-- Good: Idempotent table creation
CREATE TABLE IF NOT EXISTS public.user_assessment_attempts (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    -- ... other columns
);

-- Good: Safe column addition
ALTER TABLE public.users 
ADD COLUMN IF NOT EXISTS email_verified BOOLEAN DEFAULT FALSE;

-- Good: Safe index creation
CREATE INDEX IF NOT EXISTS idx_user_quiz_attempts_user_id 
ON public.user_quiz_attempts(user_id);
```

## Schema Design Principles

### Clear Field Names
- When creating table schema, **avoid ambiguous field names**
- Use descriptive, unambiguous column names that clearly indicate their purpose
- Prefix related fields consistently (e.g., `created_at`, `updated_at`, `deleted_at`)

```sql
-- Bad: Ambiguous
CREATE TABLE users (
    id UUID,
    name TEXT,
    date TIMESTAMPTZ,
    status TEXT
);

-- Good: Clear and descriptive
CREATE TABLE users (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    full_name TEXT NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    account_status TEXT DEFAULT 'active' CHECK (account_status IN ('active', 'suspended', 'deleted'))
);
```

### Consistent Patterns
- Use consistent naming conventions across all tables
- Standard audit fields: `created_at`, `updated_at`, `deleted_at`
- Use `user_id` for foreign keys to `auth.users(id)`
- Use UUIDs for primary keys: `id UUID DEFAULT gen_random_uuid() PRIMARY KEY`
- Use proper constraints and checks where applicable

## Row Level Security (RLS) Best Practices

### CRITICAL: Avoiding Infinite Recursion
**The #1 rule for RLS policies: NEVER create circular dependencies between tables**

Infinite recursion occurs when:
- Table A has a policy that references Table B
- Table B has a policy that references Table A
- PostgreSQL gets stuck in an infinite loop trying to evaluate permissions

### Policy Design Principles
- Make sure all RLS policies **build off one another** and do not lead to infinite recursions
- Design policies to be simple, clear, and non-overlapping
- **Each table's policies should focus primarily on that table's own data**
- Test policies thoroughly to avoid security gaps or infinite loops
- Use `EXPLAIN` to understand query plans and detect potential recursion

### Standard RLS Pattern (Safe)
```sql
-- Enable RLS
ALTER TABLE public.table_name ENABLE ROW LEVEL SECURITY;

-- Basic user-scoped policies (no cross-table references)
CREATE POLICY "Users can view their own records" ON public.table_name
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own records" ON public.table_name
    FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own records" ON public.table_name
    FOR UPDATE USING (auth.uid() = user_id);
```

### Cross-Table Reference Patterns

#### ❌ BAD: Circular References (Causes Infinite Recursion)
```sql
-- NEVER DO THIS - Creates infinite recursion
-- learning_pods policy references pod_memberships
CREATE POLICY "Pod members can view pods" ON public.learning_pods
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.pod_memberships 
            WHERE pod_memberships.pod_id = learning_pods.id 
            AND pod_memberships.user_id = auth.uid()
        )
    );

-- pod_memberships policy references learning_pods  
CREATE POLICY "Members can view memberships for their pods" ON public.pod_memberships
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.learning_pods 
            WHERE learning_pods.id = pod_memberships.pod_id 
            AND learning_pods.created_by = auth.uid()
        )
    );
-- ☝️ This creates a circular dependency: learning_pods ↔ pod_memberships
```

#### ✅ GOOD: One-Way References Only
```sql
-- Safe approach: Only one table references the other, never both ways

-- learning_pods: Simple policies, no cross-table references
CREATE POLICY "Pod creators can manage pods" ON public.learning_pods
    FOR ALL USING (created_by = auth.uid());

-- pod_memberships: Simple policies, no cross-table references  
CREATE POLICY "Users can manage own memberships" ON public.pod_memberships
    FOR ALL USING (user_id = auth.uid());

-- If cross-table access needed, add ONE additional policy (not both ways)
CREATE POLICY "Members can view pods" ON public.learning_pods
    FOR SELECT USING (
        created_by = auth.uid() OR 
        EXISTS (
            SELECT 1 FROM public.pod_memberships pm 
            WHERE pm.pod_id = learning_pods.id 
            AND pm.user_id = auth.uid() 
            AND pm.membership_status = 'active'
        )
    );
-- ☝️ Only learning_pods references pod_memberships, not the other way around
```

#### ✅ GOOD: Using Lookup Tables for Roles
```sql
-- Use separate role/permission tables to avoid circular references
CREATE POLICY "Admins can view all records" ON public.table_name
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.user_roles 
            WHERE user_id = auth.uid() AND role = 'admin'
        )
    );
-- ☝️ References user_roles table, which doesn't reference back to table_name
```

### Real-World Example: Learning Pods System

#### ❌ BAD: What We Had (Infinite Recursion)
```sql
-- Multiple policies creating circular dependencies across migrations
CREATE POLICY "Teachers can manage classroom integration" ON public.learning_pods
    FOR UPDATE USING (
        EXISTS (
            SELECT 1 FROM public.pod_memberships 
            WHERE pod_memberships.pod_id = learning_pods.id  -- Circular reference
            AND pod_memberships.user_id = auth.uid()
            AND pod_memberships.role IN ('admin', 'teacher')
        )
    );

CREATE POLICY "Pod members can view pods" ON public.learning_pods
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.pod_memberships 
            WHERE pod_memberships.pod_id = learning_pods.id  -- Another circular reference
            AND pod_memberships.user_id = auth.uid()
        )
    );

-- Plus policies on pod_memberships that reference learning_pods back
-- Result: PostgreSQL error "infinite recursion detected in policy for relation 'learning_pods'"
```

#### ✅ GOOD: What We Fixed (No Recursion)
```sql
-- Step 1: Drop ALL existing policies to break circular dependencies
DO $$ 
DECLARE 
    pol RECORD;
BEGIN
    FOR pol IN 
        SELECT policyname FROM pg_policies 
        WHERE tablename = 'learning_pods' AND schemaname = 'public'
    LOOP
        EXECUTE format('DROP POLICY IF EXISTS %I ON public.learning_pods', pol.policyname);
    END LOOP;
    
    FOR pol IN 
        SELECT policyname FROM pg_policies 
        WHERE tablename = 'pod_memberships' AND schemaname = 'public'
    LOOP
        EXECUTE format('DROP POLICY IF EXISTS %I ON public.pod_memberships', pol.policyname);
    END LOOP;
END $$;

-- Step 2: Create simple, non-circular policies
-- learning_pods: Focus on pod ownership
CREATE POLICY "learning_pods_creators_manage" ON public.learning_pods
    FOR ALL USING (created_by = auth.uid());

-- pod_memberships: Focus on membership ownership
CREATE POLICY "pod_memberships_own_view" ON public.pod_memberships
    FOR SELECT USING (user_id = auth.uid());

CREATE POLICY "pod_memberships_own_insert" ON public.pod_memberships
    FOR INSERT WITH CHECK (user_id = auth.uid());

CREATE POLICY "pod_memberships_own_update" ON public.pod_memberships
    FOR UPDATE USING (user_id = auth.uid());

-- Step 3: Add ONE cross-table policy (only one direction)
CREATE POLICY "learning_pods_members_view" ON public.learning_pods
    FOR SELECT USING (
        created_by = auth.uid() OR 
        EXISTS (
            SELECT 1 FROM public.pod_memberships pm 
            WHERE pm.pod_id = learning_pods.id 
            AND pm.user_id = auth.uid() 
            AND pm.membership_status = 'active'
        )
    );
-- ☝️ Only learning_pods references pod_memberships, never the reverse
```

### Policy Debugging and Testing

#### Check for Circular Dependencies
```sql
-- Query to find all policies that might create circular references
SELECT 
    schemaname,
    tablename,
    policyname,
    cmd,
    qual,
    with_check
FROM pg_policies 
WHERE schemaname = 'public'
AND (tablename = 'learning_pods' OR tablename = 'pod_memberships')
ORDER BY tablename, policyname;
```

#### Test Policy Performance
```sql
-- Use EXPLAIN to check for policy-related performance issues
EXPLAIN (ANALYZE, BUFFERS) 
SELECT * FROM public.learning_pods 
WHERE created_by = 'some-user-id';
```

### Migration Strategy for RLS Fixes

#### Safe RLS Policy Migration Template
```sql
-- Template for fixing circular RLS policies
BEGIN;

-- Step 1: Disable RLS temporarily
ALTER TABLE public.table1 DISABLE ROW LEVEL SECURITY;
ALTER TABLE public.table2 DISABLE ROW LEVEL SECURITY;

-- Step 2: Drop all existing policies
DO $$ 
DECLARE pol RECORD;
BEGIN
    FOR pol IN SELECT policyname FROM pg_policies 
               WHERE tablename IN ('table1', 'table2') AND schemaname = 'public'
    LOOP
        EXECUTE format('DROP POLICY IF EXISTS %I ON public.%I', pol.policyname, pol.tablename);
    END LOOP;
END $$;

-- Step 3: Re-enable RLS
ALTER TABLE public.table1 ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.table2 ENABLE ROW LEVEL SECURITY;

-- Step 4: Create simple, non-circular policies
-- (Add your specific policies here)

COMMIT;
```

## Client Configuration

### Authentication Setup
- We're using **Supabase SSR/JS**, not supabase auth helpers
- **DO NOT use auth helpers ever again**
- Use the main supabase client for all operations
- Implement singleton pattern to prevent multiple client instances

```typescript
// Good: Single client instance
import { createClient } from '@supabase/supabase-js'
import type { Database } from './database.types'

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!

export const supabase = createClient<Database>(supabaseUrl, supabaseAnonKey, {
  auth: {
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: true,
    flowType: 'pkce'
  }
})

// Bad: Multiple clients or auth helpers
// Don't do this - creates multiple GoTrueClient instances
const realtimeClient = createClient(url, key) // ❌
```

## Database Patterns

### Audit Trail Pattern
```sql
-- Standard audit fields for all tables
CREATE TABLE public.example_table (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    -- ... business fields ...
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id)
);

-- Auto-update trigger for updated_at
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_example_table_updated_at
    BEFORE UPDATE ON public.example_table
    FOR EACH ROW
    EXECUTE FUNCTION public.handle_updated_at();
```

### Soft Delete Pattern
```sql
-- Add soft delete capability
ALTER TABLE public.table_name 
ADD COLUMN IF NOT EXISTS deleted_at TIMESTAMPTZ NULL;

-- Update RLS policies to exclude soft-deleted records
CREATE POLICY "exclude_deleted" ON public.table_name
    FOR ALL USING (deleted_at IS NULL);
```

### Foreign Key Patterns
```sql
-- Always use proper foreign key constraints
CREATE TABLE public.user_quiz_attempts (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    topic_id TEXT NOT NULL REFERENCES public.question_topics(topic_id) ON DELETE CASCADE,
    -- ... other fields
);

-- Create indexes for foreign keys
CREATE INDEX IF NOT EXISTS idx_user_quiz_attempts_user_id 
ON public.user_quiz_attempts(user_id);

CREATE INDEX IF NOT EXISTS idx_user_quiz_attempts_topic_id 
ON public.user_quiz_attempts(topic_id);
```

## Performance Optimization

### Index Strategy
- Create indexes for all foreign keys
- Index frequently queried columns
- Use partial indexes for filtered queries
- Monitor query performance with `EXPLAIN ANALYZE`

```sql
-- Partial index for active records
CREATE INDEX IF NOT EXISTS idx_active_users 
ON public.users(created_at) 
WHERE deleted_at IS NULL;

-- Composite index for common query patterns
CREATE INDEX IF NOT EXISTS idx_quiz_attempts_user_date 
ON public.user_quiz_attempts(user_id, completed_at DESC);
```

### Query Optimization
- Use proper JOINs instead of multiple queries
- Leverage Supabase's select() with relationships
- Use `.limit()` and `.range()` for pagination
- Implement proper error handling for missing tables

```typescript
// Good: Single query with relationships
const { data, error } = await supabase
  .from('user_quiz_attempts')
  .select(`
    id,
    score,
    completed_at,
    question_topics(topic_title, emoji)
  `)
  .eq('user_id', userId)
  .order('completed_at', { ascending: false })
  .limit(10);

// Handle missing tables gracefully
if (error) {
  if (process.env.NODE_ENV === 'development') {
    console.warn('Table may not exist:', error);
  }
  return [];
}
```

## Error Handling & Resilience

### Graceful Degradation
- Handle missing tables gracefully in development
- Provide fallback data when database queries fail
- Log errors appropriately based on environment

```typescript
// Good: Environment-aware error handling
try {
  const { data, error } = await supabase
    .from('user_assessment_attempts')
    .select('*')
    .eq('user_id', userId);
    
  if (error) {
    if (process.env.NODE_ENV === 'development') {
      console.warn('Assessment table may not exist:', error);
    }
    return []; // Graceful fallback
  }
  
  return data || [];
} catch (error) {
  console.error('Database query failed:', error);
  return []; // Always provide fallback
}
```

### Connection Management
- Use singleton pattern for Supabase clients
- Implement proper cleanup for realtime subscriptions
- Handle connection state changes gracefully

## Security Guidelines

### Data Validation
- Always validate data on both client and server
- Use database constraints for data integrity
- Implement proper input sanitization

```sql
-- Use CHECK constraints for data validation
CREATE TABLE public.users (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    email TEXT NOT NULL CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'),
    age INTEGER CHECK (age >= 13 AND age <= 120),
    status TEXT DEFAULT 'active' CHECK (status IN ('active', 'suspended', 'deleted'))
);
```

### Permission Management
- Use role-based access control (RBAC)
- Implement least privilege principle
- Regularly audit permissions and policies

```sql
-- Role-based permissions
CREATE TABLE public.user_roles (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    role TEXT NOT NULL CHECK (role IN ('user', 'admin', 'moderator')),
    granted_at TIMESTAMPTZ DEFAULT NOW(),
    granted_by UUID REFERENCES auth.users(id),
    UNIQUE(user_id, role)
);
```

## Migration Checklist

Before deploying any migration:
- [ ] Test migration in development environment
- [ ] **Verify RLS policies don't create circular dependencies**
- [ ] Check for performance impact on large tables
- [ ] Ensure backward compatibility
- [ ] Document breaking changes
- [ ] Plan rollback strategy if needed
- [ ] Test with realistic data volumes
- [ ] **Use `EXPLAIN` to verify query plans don't show recursion**

## Common Pitfalls to Avoid

1. **Circular RLS Policies**: The #1 cause of infinite recursion - never create bidirectional policy references
2. **Multiple Supabase Clients**: Always use singleton pattern
3. **Missing Indexes**: Index all foreign keys and frequently queried columns
4. **Overly Complex RLS**: Keep policies simple and testable
5. **Ambiguous Field Names**: Use descriptive, unambiguous column names
6. **Missing Error Handling**: Always handle database errors gracefully
7. **Ignoring Performance**: Monitor query performance and optimize accordingly
8. **Security Gaps**: Test RLS policies thoroughly
9. **Non-Idempotent Migrations**: Always use IF EXISTS/IF NOT EXISTS
10. **Cross-Migration Policy Conflicts**: Each migration should be aware of existing policies

## Emergency RLS Fix Procedure

If you encounter infinite recursion in production:

```sql
-- Emergency fix: Temporarily disable RLS to restore service
ALTER TABLE public.problematic_table DISABLE ROW LEVEL SECURITY;

-- Then follow the safe migration template above to fix properly
-- Never leave RLS disabled permanently!
```