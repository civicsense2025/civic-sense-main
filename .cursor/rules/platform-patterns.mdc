---
description: 
globs: 
alwaysApply: true
---
# CivicSense Platform Patterns

## Function Architecture Patterns

### API Route Patterns
```typescript
// ✅ Good: Consistent API route structure
export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient()
    const { data: { user } } = await supabase.auth.getUser()
    
    // Validation logic
    if (!user && requiresAuth) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }
    
    // Business logic
    const result = await businessLogic()
    
    return NextResponse.json({ success: true, data: result })
  } catch (error) {
    console.error('Error in route:', error)
    return NextResponse.json({ 
      error: 'Internal server error',
      details: error instanceof Error ? error.message : 'Unknown error'
    }, { status: 500 })
  }
}
```

### Service Layer Patterns
```typescript
// ✅ Good: Service class pattern
export class CivicContentService {
  private supabase: SupabaseClient
  
  constructor() {
    this.supabase = createClient()
  }
  
  async getContent(options: ContentOptions): Promise<ContentResult> {
    // Implementation with proper error handling
  }
  
  async createContent(data: ContentInput): Promise<Content> {
    // Implementation with validation
  }
}

// ✅ Good: Function-based service pattern
export const civicContentOperations = {
  async getContent(options: ContentOptions): Promise<ContentResult> {
    // Implementation
  },
  
  async createContent(data: ContentInput): Promise<Content> {
    // Implementation
  }
}
```

### Hook Patterns
```typescript
// ✅ Good: Custom hook pattern
export function useCivicContent(filters?: ContentFilters) {
  const [content, setContent] = useState<Content[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<Error | null>(null)
  
  const loadContent = useCallback(async () => {
    try {
      setLoading(true)
      setError(null)
      const result = await civicContentOperations.getContent(filters)
      setContent(result.content)
    } catch (err) {
      setError(err as Error)
    } finally {
      setLoading(false)
    }
  }, [filters])
  
  useEffect(() => {
    loadContent()
  }, [loadContent])
  
  return {
    content,
    loading,
    error,
    refresh: loadContent,
    // Action methods
    createContent: useCallback(async (data: ContentInput) => {
      const newContent = await civicContentOperations.createContent(data)
      setContent(prev => [newContent, ...prev])
      return newContent
    }, [])
  }
}
```

## Design System Patterns

### Component Architecture
```typescript
// ✅ Good: Compound component pattern
export function QuizCard({ children, ...props }: QuizCardProps) {
  return (
    <div className="quiz-card" {...props}>
      {children}
    </div>
  )
}

QuizCard.Header = function QuizCardHeader({ children }: { children: ReactNode }) {
  return <div className="quiz-card-header">{children}</div>
}

QuizCard.Body = function QuizCardBody({ children }: { children: ReactNode }) {
  return <div className="quiz-card-body">{children}</div>
}

QuizCard.Actions = function QuizCardActions({ children }: { children: ReactNode }) {
  return <div className="quiz-card-actions">{children}</div>
}

// Usage:
<QuizCard>
  <QuizCard.Header>
    <h3>Constitutional Rights Quiz</h3>
  </QuizCard.Header>
  <QuizCard.Body>
    <p>Test your knowledge of constitutional protections...</p>
  </QuizCard.Body>
  <QuizCard.Actions>
    <Button>Start Quiz</Button>
  </QuizCard.Actions>
</QuizCard>
```

### State Management Patterns
```typescript
// ✅ Good: Context + Reducer pattern for complex state
interface QuizState {
  currentQuestion: number
  answers: Record<string, string>
  timeRemaining: number
  isSubmitted: boolean
}

type QuizAction = 
  | { type: 'ANSWER_QUESTION'; questionId: string; answer: string }
  | { type: 'NEXT_QUESTION' }
  | { type: 'TICK_TIMER' }
  | { type: 'SUBMIT_QUIZ' }

const quizReducer = (state: QuizState, action: QuizAction): QuizState => {
  switch (action.type) {
    case 'ANSWER_QUESTION':
      return {
        ...state,
        answers: { ...state.answers, [action.questionId]: action.answer }
      }
    // Other cases...
    default:
      return state
  }
}

export function QuizProvider({ children }: { children: ReactNode }) {
  const [state, dispatch] = useReducer(quizReducer, initialState)
  
  return (
    <QuizContext.Provider value={{ state, dispatch }}>
      {children}
    </QuizContext.Provider>
  )
}
```

### UI Pattern Consistency
```typescript
// ✅ Good: Consistent loading states
export function LoadingSpinner({ size = 'md', text }: LoadingProps) {
  return (
    <div className={`loading-spinner loading-spinner--${size}`}>
      <div className="spinner" />
      {text && <span className="loading-text">{text}</span>}
    </div>
  )
}

// ✅ Good: Consistent error boundaries
export function ErrorBoundary({ children, fallback }: ErrorBoundaryProps) {
  return (
    <ErrorBoundaryReact
      FallbackComponent={fallback || DefaultErrorFallback}
      onError={(error, errorInfo) => {
        console.error('Error caught by boundary:', error, errorInfo)
        // Send to error tracking service
      }}
    >
      {children}
    </ErrorBoundaryReact>
  )
}
```

## Data Flow Patterns

### Server-Client Data Sync
```typescript
// ✅ Good: Optimistic updates pattern
export function useOptimisticQuizProgress() {
  const [progress, setProgress] = useState<QuizProgress[]>([])
  const [optimisticUpdates, setOptimisticUpdates] = useState<Map<string, QuizProgress>>(new Map())
  
  const updateProgress = useCallback(async (update: ProgressUpdate) => {
    const tempId = generateTempId()
    const optimisticProgress = { ...update, id: tempId, pending: true }
    
    // Apply optimistic update
    setOptimisticUpdates(prev => new Map(prev).set(tempId, optimisticProgress))
    
    try {
      const result = await api.updateProgress(update)
      
      // Replace optimistic update with real data
      setProgress(prev => prev.map(p => p.id === tempId ? result : p))
      setOptimisticUpdates(prev => {
        const newMap = new Map(prev)
        newMap.delete(tempId)
        return newMap
      })
    } catch (error) {
      // Remove failed optimistic update
      setOptimisticUpdates(prev => {
        const newMap = new Map(prev)
        newMap.delete(tempId)
        return newMap
      })
      throw error
    }
  }, [])
  
  return { progress, updateProgress }
}
```

### Real-time Data Patterns
```typescript
// ✅ Good: Supabase real-time subscription pattern
export function useRealTimeMultiplayerRoom(roomId: string) {
  const [room, setRoom] = useState<MultiplayerRoom | null>(null)
  const [players, setPlayers] = useState<Player[]>([])
  const channelRef = useRef<RealtimeChannel | null>(null)
  
  useEffect(() => {
    if (!roomId) return
    
    const channel = supabase
      .channel(`room:${roomId}`)
      .on('postgres_changes', {
        event: '*',
        schema: 'public',
        table: 'multiplayer_room_players',
        filter: `room_id=eq.${roomId}`
      }, (payload) => {
        if (payload.eventType === 'INSERT') {
          setPlayers(prev => [...prev, payload.new as Player])
        } else if (payload.eventType === 'UPDATE') {
          setPlayers(prev => prev.map(p => p.id === payload.new.id ? payload.new as Player : p))
        } else if (payload.eventType === 'DELETE') {
          setPlayers(prev => prev.filter(p => p.id !== payload.old.id))
        }
      })
      .subscribe()
    
    channelRef.current = channel
    
    return () => {
      if (channelRef.current) {
        supabase.removeChannel(channelRef.current)
      }
    }
  }, [roomId])
  
  return { room, players }
}
```

## Performance Patterns

### Memoization Strategy
```typescript
// ✅ Good: Strategic memoization
export const QuizQuestion = memo(function QuizQuestion({ 
  question, 
  onAnswer, 
  selectedAnswer 
}: QuizQuestionProps) {
  // Memoize expensive calculations
  const difficultyColor = useMemo(() => 
    getDifficultyColor(question.difficulty), 
    [question.difficulty]
  )
  
  // Memoize callback to prevent unnecessary re-renders
  const handleAnswer = useCallback((answer: string) => {
    onAnswer(question.id, answer)
  }, [question.id, onAnswer])
  
  return (
    <div className="quiz-question">
      <QuestionText difficulty={difficultyColor}>
        {question.text}
      </QuestionText>
      <AnswerOptions 
        options={question.options}
        selected={selectedAnswer}
        onSelect={handleAnswer}
      />
    </div>
  )
})

// ✅ Good: Complex computation memoization
const useQuizAnalytics = (quizAttempts: QuizAttempt[]) => {
  return useMemo(() => {
    if (!quizAttempts.length) return null
    
    return {
      averageScore: calculateAverageScore(quizAttempts),
      improvementTrend: calculateImprovementTrend(quizAttempts),
      categoryBreakdown: analyzeCategoryPerformance(quizAttempts),
      timeSpentAnalysis: analyzeTimePatterns(quizAttempts)
    }
  }, [quizAttempts])
}
```

### Code Splitting Patterns
```typescript
// ✅ Good: Route-based code splitting
const AdminDashboard = lazy(() => import('@/components/admin/admin-dashboard'))
const QuizBuilder = lazy(() => import('@/components/quiz/quiz-builder'))
const AnalyticsDashboard = lazy(() => import('@/components/analytics/analytics-dashboard'))

// ✅ Good: Feature-based code splitting
const MultiplayerGame = lazy(() => 
  import('@/components/multiplayer/multiplayer-game').then(module => ({
    default: module.MultiplayerGame
  }))
)

// ✅ Good: Component-level splitting for heavy features
export function AdminPanel() {
  const [activeTab, setActiveTab] = useState('users')
  
  return (
    <div className="admin-panel">
      <TabNavigation activeTab={activeTab} onTabChange={setActiveTab} />
      <Suspense fallback={<LoadingSpinner text="Loading admin tools..." />}>
        {activeTab === 'users' && <UserManagement />}
        {activeTab === 'content' && <ContentManagement />}
        {activeTab === 'analytics' && <AnalyticsDashboard />}
      </Suspense>
    </div>
  )
}
```

## Security Patterns

### Input Validation
```typescript
// ✅ Good: Zod schema validation
const CreateQuizSchema = z.object({
  title: z.string().min(1).max(200),
  description: z.string().max(1000).optional(),
  questions: z.array(z.object({
    text: z.string().min(1),
    options: z.array(z.string()).min(2).max(6),
    correctAnswer: z.number().min(0),
    explanation: z.string().optional()
  })).min(1).max(50),
  category: z.string().min(1),
  difficulty: z.enum(['easy', 'medium', 'hard'])
})

export async function createQuiz(data: unknown) {
  const validatedData = CreateQuizSchema.parse(data)
  // Proceed with validated data
}
```

### RLS Policy Patterns
```sql
-- ✅ Good: User-scoped RLS policies
CREATE POLICY "Users can only see their own quiz attempts"
ON user_quiz_attempts
FOR ALL
USING (auth.uid() = user_id);

-- ✅ Good: Role-based access
CREATE POLICY "Admins can manage all content"
ON question_topics
FOR ALL
USING (
  EXISTS (
    SELECT 1 FROM user_roles 
    WHERE user_id = auth.uid() 
    AND role = 'admin'
  )
);
```

## Testing Patterns

### Component Testing
```typescript
// ✅ Good: Comprehensive component testing
describe('QuizQuestion', () => {
  const mockQuestion = {
    id: 'q1',
    text: 'What is the first amendment?',
    options: ['Free speech', 'Right to bear arms', 'Due process', 'Voting rights'],
    correctAnswer: 0,
    difficulty: 'medium'
  }
  
  it('renders question text and options', () => {
    render(<QuizQuestion question={mockQuestion} onAnswer={() => {}} />)
    
    expect(screen.getByText(mockQuestion.text)).toBeInTheDocument()
    mockQuestion.options.forEach(option => {
      expect(screen.getByText(option)).toBeInTheDocument()
    })
  })
  
  it('calls onAnswer when option is selected', () => {
    const onAnswer = jest.fn()
    render(<QuizQuestion question={mockQuestion} onAnswer={onAnswer} />)
    
    fireEvent.click(screen.getByText('Free speech'))
    
    expect(onAnswer).toHaveBeenCalledWith('q1', 'Free speech')
  })
})
```

### Integration Testing
```typescript
// ✅ Good: API route testing
describe('/api/quiz/[topicId]', () => {
  it('returns quiz questions for authenticated user', async () => {
    const mockUser = await createTestUser()
    const mockTopic = await createTestTopic()
    
    const response = await request(app)
      .get(`/api/quiz/${mockTopic.id}`)
      .set('Authorization', `Bearer ${mockUser.token}`)
      .expect(200)
    
    expect(response.body).toMatchObject({
      success: true,
      data: {
        topic: expect.objectContaining({
          id: mockTopic.id,
          title: mockTopic.title
        }),
        questions: expect.arrayContaining([
          expect.objectContaining({
            text: expect.any(String),
            options: expect.any(Array)
          })
        ])
      }
    })
  })
})
```

## Error Handling Patterns

### Global Error Boundaries
```typescript
// ✅ Good: Hierarchical error boundaries
export function AppErrorBoundary({ children }: { children: ReactNode }) {
  return (
    <ErrorBoundary
      FallbackComponent={AppErrorFallback}
      onError={(error, errorInfo) => {
        console.error('App-level error:', error, errorInfo)
        trackError(error, { level: 'app', errorInfo })
      }}
    >
      {children}
    </ErrorBoundary>
  )
}

export function FeatureErrorBoundary({ 
  children, 
  featureName 
}: { 
  children: ReactNode
  featureName: string 
}) {
  return (
    <ErrorBoundary
      FallbackComponent={({ error, resetErrorBoundary }) => (
        <FeatureErrorFallback 
          error={error}
          featureName={featureName}
          onRetry={resetErrorBoundary}
        />
      )}
      onError={(error, errorInfo) => {
        console.error(`${featureName} error:`, error, errorInfo)
        trackError(error, { level: 'feature', feature: featureName, errorInfo })
      }}
    >
      {children}
    </ErrorBoundary>
  )
}
```

## File Organization Patterns

### Feature-Based Structure
```
src/
├── components/
│   ├── ui/                    # Reusable UI components
│   ├── quiz/                  # Quiz-specific components
│   ├── multiplayer/           # Multiplayer-specific components
│   └── admin/                 # Admin-specific components
├── lib/
│   ├── services/              # Business logic services
│   ├── hooks/                 # Custom React hooks
│   ├── utils/                 # Utility functions
│   └── types/                 # TypeScript type definitions
├── app/
│   ├── api/                   # API routes
│   ├── quiz/                  # Quiz pages
│   └── admin/                 # Admin pages
└── tests/
    ├── __mocks__/             # Test mocks
    ├── fixtures/              # Test data
    └── utils/                 # Test utilities
```

### Import Organization
```typescript
// ✅ Good: Consistent import order
// 1. React and external libraries
import React, { useState, useEffect } from 'react'
import { useRouter } from 'next/navigation'
import { motion } from 'framer-motion'

// 2. Internal services and utilities
import { quizService } from '@/lib/services/quiz-service'
import { formatDate } from '@/lib/utils/date'

// 3. UI components (external first, then internal)
import { Button } from '@/components/ui/button'
import { QuizCard } from '@/components/quiz/quiz-card'

// 4. Types and constants
import type { Quiz, QuizAttempt } from '@/lib/types/quiz'
import { QUIZ_TYPES } from '@/lib/constants/quiz'
```

## Documentation Patterns

### Function Documentation
```typescript
/**
 * Analyzes quiz performance and generates insights for improvement
 * 
 * @param attempts - Array of quiz attempts to analyze
 * @param options - Configuration options for analysis
 * @returns Promise resolving to performance insights
 * 
 * @example
 * ```typescript
 * const insights = await analyzeQuizPerformance(userAttempts, {
 *   includeTimeAnalysis: true,
 *   groupByCategory: true
 * })
 * ```
 * 
 * @throws {ValidationError} When attempts array is empty
 * @throws {AnalysisError} When analysis computation fails
 */
export async function analyzeQuizPerformance(
  attempts: QuizAttempt[],
  options: AnalysisOptions = {}
): Promise<PerformanceInsights> {
  // Implementation
}
```

### Component Documentation
```typescript
/**
 * MultiplayerQuizRoom - Real-time multiplayer quiz component
 * 
 * Manages the complete multiplayer quiz experience including:
 * - Player management and real-time updates
 * - Question progression and timing
 * - Score calculation and leaderboard
 * - Chat and interaction features
 * 
 * @example
 * ```tsx
 * <MultiplayerQuizRoom
 *   roomId="room_123"
 *   playerId="player_456"
 *   onGameComplete={(results) => console.log(results)}
 *   allowChat={true}
 * />
 * ```
 */
export interface MultiplayerQuizRoomProps {
  /** Unique identifier for the multiplayer room */
  roomId: string
  /** Current player's unique identifier */
  playerId: string
  /** Callback fired when the quiz game completes */
  onGameComplete?: (results: GameResults) => void
  /** Whether to enable chat functionality */
  allowChat?: boolean
  /** Custom styling classes */
  className?: string
}
```

## Platform-Specific Patterns

### Mobile-First Responsive Design
```typescript
// ✅ Good: Mobile-first component design
export function ResponsiveQuizCard({ quiz }: { quiz: Quiz }) {
  return (
    <motion.div 
      className={cn(
        // Mobile-first base styles
        "p-4 rounded-lg border bg-white shadow-sm",
        // Tablet styles
        "md:p-6 md:shadow-md",
        // Desktop styles
        "lg:p-8 lg:hover:shadow-lg lg:transition-shadow"
      )}
      // Mobile-optimized animations
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.3 }}
      // Touch-friendly interactions
      whileTap={{ scale: 0.98 }}
    >
      <div className="space-y-3 md:space-y-4">
        <h3 className="text-lg font-semibold md:text-xl lg:text-2xl">
          {quiz.title}
        </h3>
        <p className="text-sm text-gray-600 md:text-base line-clamp-2 md:line-clamp-3">
          {quiz.description}
        </p>
        <div className="flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between">
          <QuizMetadata quiz={quiz} />
          <Button 
            size="sm" 
            className="w-full sm:w-auto"
            aria-label={`Start ${quiz.title} quiz`}
          >
            Start Quiz
          </Button>
        </div>
      </div>
    </motion.div>
  )
}
```

### Accessibility Patterns
```typescript
// ✅ Good: Comprehensive accessibility
export function AccessibleQuizQuestion({ 
  question, 
  questionNumber, 
  totalQuestions,
  onAnswer 
}: QuizQuestionProps) {
  const [selectedAnswer, setSelectedAnswer] = useState<string | null>(null)
  const [announced, setAnnounced] = useState(false)
  
  // Announce question to screen readers
  useEffect(() => {
    if (!announced) {
      const announcement = `Question ${questionNumber} of ${totalQuestions}: ${question.text}`
      announceToScreenReader(announcement)
      setAnnounced(true)
    }
  }, [question.text, questionNumber, totalQuestions, announced])
  
  return (
    <div 
      className="quiz-question"
      role="group"
      aria-labelledby={`question-${question.id}`}
      aria-describedby={`question-progress-${question.id}`}
    >
      <div 
        id={`question-progress-${question.id}`}
        className="sr-only"
        aria-live="polite"
      >
        Question {questionNumber} of {totalQuestions}
      </div>
      
      <h2 
        id={`question-${question.id}`}
        className="question-text"
      >
        {question.text}
      </h2>
      
      <fieldset className="answer-options">
        <legend className="sr-only">Select your answer</legend>
        
        {question.options.map((option, index) => (
          <label 
            key={index}
            className={cn(
              "answer-option",
              selectedAnswer === option && "selected"
            )}
          >
            <input
              type="radio"
              name={`question-${question.id}`}
              value={option}
              checked={selectedAnswer === option}
              onChange={() => {
                setSelectedAnswer(option)
                onAnswer(option)
              }}
              className="sr-only"
            />
            <span className="option-indicator" aria-hidden="true" />
            <span className="option-text">{option}</span>
          </label>
        ))}
      </fieldset>
    </div>
  )
}
```

---

**Remember**: These patterns ensure consistency, maintainability, and scalability across the CivicSense platform. Always consider accessibility, performance, and the civic education mission when implementing new features.
